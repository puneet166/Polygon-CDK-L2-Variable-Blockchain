// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hashdb.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hashdb_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_hashdb_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_hashdb_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_hashdb_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[40]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_hashdb_2eproto;
namespace hashdb {
namespace v1 {
class CancelBatchRequest;
class CancelBatchRequestDefaultTypeInternal;
extern CancelBatchRequestDefaultTypeInternal _CancelBatchRequest_default_instance_;
class CancelBatchResponse;
class CancelBatchResponseDefaultTypeInternal;
extern CancelBatchResponseDefaultTypeInternal _CancelBatchResponse_default_instance_;
class ConsolidateStateRequest;
class ConsolidateStateRequestDefaultTypeInternal;
extern ConsolidateStateRequestDefaultTypeInternal _ConsolidateStateRequest_default_instance_;
class ConsolidateStateResponse;
class ConsolidateStateResponseDefaultTypeInternal;
extern ConsolidateStateResponseDefaultTypeInternal _ConsolidateStateResponse_default_instance_;
class FeList;
class FeListDefaultTypeInternal;
extern FeListDefaultTypeInternal _FeList_default_instance_;
class Fea;
class FeaDefaultTypeInternal;
extern FeaDefaultTypeInternal _Fea_default_instance_;
class Fea12;
class Fea12DefaultTypeInternal;
extern Fea12DefaultTypeInternal _Fea12_default_instance_;
class FlushRequest;
class FlushRequestDefaultTypeInternal;
extern FlushRequestDefaultTypeInternal _FlushRequest_default_instance_;
class FlushResponse;
class FlushResponseDefaultTypeInternal;
extern FlushResponseDefaultTypeInternal _FlushResponse_default_instance_;
class GetFlushDataRequest;
class GetFlushDataRequestDefaultTypeInternal;
extern GetFlushDataRequestDefaultTypeInternal _GetFlushDataRequest_default_instance_;
class GetFlushDataResponse;
class GetFlushDataResponseDefaultTypeInternal;
extern GetFlushDataResponseDefaultTypeInternal _GetFlushDataResponse_default_instance_;
class GetFlushDataResponse_NodesEntry_DoNotUse;
class GetFlushDataResponse_NodesEntry_DoNotUseDefaultTypeInternal;
extern GetFlushDataResponse_NodesEntry_DoNotUseDefaultTypeInternal _GetFlushDataResponse_NodesEntry_DoNotUse_default_instance_;
class GetFlushDataResponse_ProgramEntry_DoNotUse;
class GetFlushDataResponse_ProgramEntry_DoNotUseDefaultTypeInternal;
extern GetFlushDataResponse_ProgramEntry_DoNotUseDefaultTypeInternal _GetFlushDataResponse_ProgramEntry_DoNotUse_default_instance_;
class GetFlushStatusResponse;
class GetFlushStatusResponseDefaultTypeInternal;
extern GetFlushStatusResponseDefaultTypeInternal _GetFlushStatusResponse_default_instance_;
class GetProgramRequest;
class GetProgramRequestDefaultTypeInternal;
extern GetProgramRequestDefaultTypeInternal _GetProgramRequest_default_instance_;
class GetProgramResponse;
class GetProgramResponseDefaultTypeInternal;
extern GetProgramResponseDefaultTypeInternal _GetProgramResponse_default_instance_;
class GetRequest;
class GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
class GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class GetResponse_DbReadLogEntry_DoNotUse;
class GetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal;
extern GetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal _GetResponse_DbReadLogEntry_DoNotUse_default_instance_;
class GetResponse_SiblingsEntry_DoNotUse;
class GetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal;
extern GetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal _GetResponse_SiblingsEntry_DoNotUse_default_instance_;
class HashValueGL;
class HashValueGLDefaultTypeInternal;
extern HashValueGLDefaultTypeInternal _HashValueGL_default_instance_;
class KeyValue;
class KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class LoadDBRequest;
class LoadDBRequestDefaultTypeInternal;
extern LoadDBRequestDefaultTypeInternal _LoadDBRequest_default_instance_;
class LoadDBRequest_InputDbEntry_DoNotUse;
class LoadDBRequest_InputDbEntry_DoNotUseDefaultTypeInternal;
extern LoadDBRequest_InputDbEntry_DoNotUseDefaultTypeInternal _LoadDBRequest_InputDbEntry_DoNotUse_default_instance_;
class LoadProgramDBRequest;
class LoadProgramDBRequestDefaultTypeInternal;
extern LoadProgramDBRequestDefaultTypeInternal _LoadProgramDBRequest_default_instance_;
class LoadProgramDBRequest_InputProgramDbEntry_DoNotUse;
class LoadProgramDBRequest_InputProgramDbEntry_DoNotUseDefaultTypeInternal;
extern LoadProgramDBRequest_InputProgramDbEntry_DoNotUseDefaultTypeInternal _LoadProgramDBRequest_InputProgramDbEntry_DoNotUse_default_instance_;
class PurgeRequest;
class PurgeRequestDefaultTypeInternal;
extern PurgeRequestDefaultTypeInternal _PurgeRequest_default_instance_;
class PurgeResponse;
class PurgeResponseDefaultTypeInternal;
extern PurgeResponseDefaultTypeInternal _PurgeResponse_default_instance_;
class ReadTreeRequest;
class ReadTreeRequestDefaultTypeInternal;
extern ReadTreeRequestDefaultTypeInternal _ReadTreeRequest_default_instance_;
class ReadTreeResponse;
class ReadTreeResponseDefaultTypeInternal;
extern ReadTreeResponseDefaultTypeInternal _ReadTreeResponse_default_instance_;
class ResultCode;
class ResultCodeDefaultTypeInternal;
extern ResultCodeDefaultTypeInternal _ResultCode_default_instance_;
class SemiFlushRequest;
class SemiFlushRequestDefaultTypeInternal;
extern SemiFlushRequestDefaultTypeInternal _SemiFlushRequest_default_instance_;
class SetProgramRequest;
class SetProgramRequestDefaultTypeInternal;
extern SetProgramRequestDefaultTypeInternal _SetProgramRequest_default_instance_;
class SetProgramResponse;
class SetProgramResponseDefaultTypeInternal;
extern SetProgramResponseDefaultTypeInternal _SetProgramResponse_default_instance_;
class SetRequest;
class SetRequestDefaultTypeInternal;
extern SetRequestDefaultTypeInternal _SetRequest_default_instance_;
class SetResponse;
class SetResponseDefaultTypeInternal;
extern SetResponseDefaultTypeInternal _SetResponse_default_instance_;
class SetResponse_DbReadLogEntry_DoNotUse;
class SetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal;
extern SetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal _SetResponse_DbReadLogEntry_DoNotUse_default_instance_;
class SetResponse_SiblingsEntry_DoNotUse;
class SetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal;
extern SetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal _SetResponse_SiblingsEntry_DoNotUse_default_instance_;
class SiblingList;
class SiblingListDefaultTypeInternal;
extern SiblingListDefaultTypeInternal _SiblingList_default_instance_;
class Version;
class VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace v1
}  // namespace hashdb
PROTOBUF_NAMESPACE_OPEN
template<> ::hashdb::v1::CancelBatchRequest* Arena::CreateMaybeMessage<::hashdb::v1::CancelBatchRequest>(Arena*);
template<> ::hashdb::v1::CancelBatchResponse* Arena::CreateMaybeMessage<::hashdb::v1::CancelBatchResponse>(Arena*);
template<> ::hashdb::v1::ConsolidateStateRequest* Arena::CreateMaybeMessage<::hashdb::v1::ConsolidateStateRequest>(Arena*);
template<> ::hashdb::v1::ConsolidateStateResponse* Arena::CreateMaybeMessage<::hashdb::v1::ConsolidateStateResponse>(Arena*);
template<> ::hashdb::v1::FeList* Arena::CreateMaybeMessage<::hashdb::v1::FeList>(Arena*);
template<> ::hashdb::v1::Fea* Arena::CreateMaybeMessage<::hashdb::v1::Fea>(Arena*);
template<> ::hashdb::v1::Fea12* Arena::CreateMaybeMessage<::hashdb::v1::Fea12>(Arena*);
template<> ::hashdb::v1::FlushRequest* Arena::CreateMaybeMessage<::hashdb::v1::FlushRequest>(Arena*);
template<> ::hashdb::v1::FlushResponse* Arena::CreateMaybeMessage<::hashdb::v1::FlushResponse>(Arena*);
template<> ::hashdb::v1::GetFlushDataRequest* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataRequest>(Arena*);
template<> ::hashdb::v1::GetFlushDataResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataResponse>(Arena*);
template<> ::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::GetFlushStatusResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushStatusResponse>(Arena*);
template<> ::hashdb::v1::GetProgramRequest* Arena::CreateMaybeMessage<::hashdb::v1::GetProgramRequest>(Arena*);
template<> ::hashdb::v1::GetProgramResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetProgramResponse>(Arena*);
template<> ::hashdb::v1::GetRequest* Arena::CreateMaybeMessage<::hashdb::v1::GetRequest>(Arena*);
template<> ::hashdb::v1::GetResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetResponse>(Arena*);
template<> ::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::HashValueGL* Arena::CreateMaybeMessage<::hashdb::v1::HashValueGL>(Arena*);
template<> ::hashdb::v1::KeyValue* Arena::CreateMaybeMessage<::hashdb::v1::KeyValue>(Arena*);
template<> ::hashdb::v1::LoadDBRequest* Arena::CreateMaybeMessage<::hashdb::v1::LoadDBRequest>(Arena*);
template<> ::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::LoadProgramDBRequest* Arena::CreateMaybeMessage<::hashdb::v1::LoadProgramDBRequest>(Arena*);
template<> ::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::PurgeRequest* Arena::CreateMaybeMessage<::hashdb::v1::PurgeRequest>(Arena*);
template<> ::hashdb::v1::PurgeResponse* Arena::CreateMaybeMessage<::hashdb::v1::PurgeResponse>(Arena*);
template<> ::hashdb::v1::ReadTreeRequest* Arena::CreateMaybeMessage<::hashdb::v1::ReadTreeRequest>(Arena*);
template<> ::hashdb::v1::ReadTreeResponse* Arena::CreateMaybeMessage<::hashdb::v1::ReadTreeResponse>(Arena*);
template<> ::hashdb::v1::ResultCode* Arena::CreateMaybeMessage<::hashdb::v1::ResultCode>(Arena*);
template<> ::hashdb::v1::SemiFlushRequest* Arena::CreateMaybeMessage<::hashdb::v1::SemiFlushRequest>(Arena*);
template<> ::hashdb::v1::SetProgramRequest* Arena::CreateMaybeMessage<::hashdb::v1::SetProgramRequest>(Arena*);
template<> ::hashdb::v1::SetProgramResponse* Arena::CreateMaybeMessage<::hashdb::v1::SetProgramResponse>(Arena*);
template<> ::hashdb::v1::SetRequest* Arena::CreateMaybeMessage<::hashdb::v1::SetRequest>(Arena*);
template<> ::hashdb::v1::SetResponse* Arena::CreateMaybeMessage<::hashdb::v1::SetResponse>(Arena*);
template<> ::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::SiblingList* Arena::CreateMaybeMessage<::hashdb::v1::SiblingList>(Arena*);
template<> ::hashdb::v1::Version* Arena::CreateMaybeMessage<::hashdb::v1::Version>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hashdb {
namespace v1 {

enum ResultCode_Code : int {
  ResultCode_Code_CODE_UNSPECIFIED = 0,
  ResultCode_Code_CODE_SUCCESS = 1,
  ResultCode_Code_CODE_DB_KEY_NOT_FOUND = 2,
  ResultCode_Code_CODE_DB_ERROR = 3,
  ResultCode_Code_CODE_INTERNAL_ERROR = 4,
  ResultCode_Code_CODE_SMT_INVALID_DATA_SIZE = 14,
  ResultCode_Code_ResultCode_Code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResultCode_Code_ResultCode_Code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResultCode_Code_IsValid(int value);
constexpr ResultCode_Code ResultCode_Code_Code_MIN = ResultCode_Code_CODE_UNSPECIFIED;
constexpr ResultCode_Code ResultCode_Code_Code_MAX = ResultCode_Code_CODE_SMT_INVALID_DATA_SIZE;
constexpr int ResultCode_Code_Code_ARRAYSIZE = ResultCode_Code_Code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResultCode_Code_descriptor();
template<typename T>
inline const std::string& ResultCode_Code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResultCode_Code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResultCode_Code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResultCode_Code_descriptor(), enum_t_value);
}
inline bool ResultCode_Code_Parse(
    const std::string& name, ResultCode_Code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResultCode_Code>(
    ResultCode_Code_descriptor(), name, value);
}
enum Persistence : int {
  PERSISTENCE_CACHE_UNSPECIFIED = 0,
  PERSISTENCE_DATABASE = 1,
  PERSISTENCE_TEMPORARY = 2,
  Persistence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Persistence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Persistence_IsValid(int value);
constexpr Persistence Persistence_MIN = PERSISTENCE_CACHE_UNSPECIFIED;
constexpr Persistence Persistence_MAX = PERSISTENCE_TEMPORARY;
constexpr int Persistence_ARRAYSIZE = Persistence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Persistence_descriptor();
template<typename T>
inline const std::string& Persistence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Persistence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Persistence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Persistence_descriptor(), enum_t_value);
}
inline bool Persistence_Parse(
    const std::string& name, Persistence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Persistence>(
    Persistence_descriptor(), name, value);
}
// ===================================================================

class Version PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.Version) */ {
 public:
  inline Version() : Version(nullptr) {};
  virtual ~Version();

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Version& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Version* New() const final {
    return CreateMaybeMessage<Version>(nullptr);
  }

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kV001FieldNumber = 1,
  };
  // string v0_0_1 = 1;
  void clear_v0_0_1();
  const std::string& v0_0_1() const;
  void set_v0_0_1(const std::string& value);
  void set_v0_0_1(std::string&& value);
  void set_v0_0_1(const char* value);
  void set_v0_0_1(const char* value, size_t size);
  std::string* mutable_v0_0_1();
  std::string* release_v0_0_1();
  void set_allocated_v0_0_1(std::string* v0_0_1);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_v0_0_1();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_v0_0_1(
      std::string* v0_0_1);
  private:
  const std::string& _internal_v0_0_1() const;
  void _internal_set_v0_0_1(const std::string& value);
  std::string* _internal_mutable_v0_0_1();
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.Version)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v0_0_1_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetRequest) */ {
 public:
  inline SetRequest() : SetRequest(nullptr) {};
  virtual ~SetRequest();

  SetRequest(const SetRequest& from);
  SetRequest(SetRequest&& from) noexcept
    : SetRequest() {
    *this = ::std::move(from);
  }

  inline SetRequest& operator=(const SetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetRequest& operator=(SetRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetRequest* internal_default_instance() {
    return reinterpret_cast<const SetRequest*>(
               &_SetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SetRequest& a, SetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetRequest* New() const final {
    return CreateMaybeMessage<SetRequest>(nullptr);
  }

  SetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetRequest& from);
  void MergeFrom(const SetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SetRequest";
  }
  protected:
  explicit SetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kBatchUuidFieldNumber = 7,
    kOldRootFieldNumber = 1,
    kKeyFieldNumber = 2,
    kPersistenceFieldNumber = 4,
    kDetailsFieldNumber = 5,
    kGetDbReadLogFieldNumber = 6,
    kTxFieldNumber = 8,
  };
  // string value = 3;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string batch_uuid = 7;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  void set_batch_uuid(const std::string& value);
  void set_batch_uuid(std::string&& value);
  void set_batch_uuid(const char* value);
  void set_batch_uuid(const char* value, size_t size);
  std::string* mutable_batch_uuid();
  std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_batch_uuid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_batch_uuid(
      std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // .hashdb.v1.Fea old_root = 1;
  bool has_old_root() const;
  private:
  bool _internal_has_old_root() const;
  public:
  void clear_old_root();
  const ::hashdb::v1::Fea& old_root() const;
  ::hashdb::v1::Fea* release_old_root();
  ::hashdb::v1::Fea* mutable_old_root();
  void set_allocated_old_root(::hashdb::v1::Fea* old_root);
  private:
  const ::hashdb::v1::Fea& _internal_old_root() const;
  ::hashdb::v1::Fea* _internal_mutable_old_root();
  public:
  void unsafe_arena_set_allocated_old_root(
      ::hashdb::v1::Fea* old_root);
  ::hashdb::v1::Fea* unsafe_arena_release_old_root();

  // .hashdb.v1.Fea key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // .hashdb.v1.Persistence persistence = 4;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // bool details = 5;
  void clear_details();
  bool details() const;
  void set_details(bool value);
  private:
  bool _internal_details() const;
  void _internal_set_details(bool value);
  public:

  // bool get_db_read_log = 6;
  void clear_get_db_read_log();
  bool get_db_read_log() const;
  void set_get_db_read_log(bool value);
  private:
  bool _internal_get_db_read_log() const;
  void _internal_set_get_db_read_log(bool value);
  public:

  // uint64 tx = 8;
  void clear_tx();
  ::PROTOBUF_NAMESPACE_ID::uint64 tx() const;
  void set_tx(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tx() const;
  void _internal_set_tx(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.SetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
  ::hashdb::v1::Fea* old_root_;
  ::hashdb::v1::Fea* key_;
  int persistence_;
  bool details_;
  bool get_db_read_log_;
  ::PROTOBUF_NAMESPACE_ID::uint64 tx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetRequest) */ {
 public:
  inline GetRequest() : GetRequest(nullptr) {};
  virtual ~GetRequest();

  GetRequest(const GetRequest& from);
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRequest* New() const final {
    return CreateMaybeMessage<GetRequest>(nullptr);
  }

  GetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetRequest";
  }
  protected:
  explicit GetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 5,
    kRootFieldNumber = 1,
    kKeyFieldNumber = 2,
    kDetailsFieldNumber = 3,
    kGetDbReadLogFieldNumber = 4,
  };
  // string batch_uuid = 5;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  void set_batch_uuid(const std::string& value);
  void set_batch_uuid(std::string&& value);
  void set_batch_uuid(const char* value);
  void set_batch_uuid(const char* value, size_t size);
  std::string* mutable_batch_uuid();
  std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_batch_uuid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_batch_uuid(
      std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // .hashdb.v1.Fea root = 1;
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::hashdb::v1::Fea& root() const;
  ::hashdb::v1::Fea* release_root();
  ::hashdb::v1::Fea* mutable_root();
  void set_allocated_root(::hashdb::v1::Fea* root);
  private:
  const ::hashdb::v1::Fea& _internal_root() const;
  ::hashdb::v1::Fea* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::hashdb::v1::Fea* root);
  ::hashdb::v1::Fea* unsafe_arena_release_root();

  // .hashdb.v1.Fea key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // bool details = 3;
  void clear_details();
  bool details() const;
  void set_details(bool value);
  private:
  bool _internal_details() const;
  void _internal_set_details(bool value);
  public:

  // bool get_db_read_log = 4;
  void clear_get_db_read_log();
  bool get_db_read_log() const;
  void set_get_db_read_log(bool value);
  private:
  bool _internal_get_db_read_log() const;
  void _internal_set_get_db_read_log(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
  ::hashdb::v1::Fea* root_;
  ::hashdb::v1::Fea* key_;
  bool details_;
  bool get_db_read_log_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetProgramRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetProgramRequest) */ {
 public:
  inline SetProgramRequest() : SetProgramRequest(nullptr) {};
  virtual ~SetProgramRequest();

  SetProgramRequest(const SetProgramRequest& from);
  SetProgramRequest(SetProgramRequest&& from) noexcept
    : SetProgramRequest() {
    *this = ::std::move(from);
  }

  inline SetProgramRequest& operator=(const SetProgramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetProgramRequest& operator=(SetProgramRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetProgramRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetProgramRequest* internal_default_instance() {
    return reinterpret_cast<const SetProgramRequest*>(
               &_SetProgramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SetProgramRequest& a, SetProgramRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetProgramRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetProgramRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetProgramRequest* New() const final {
    return CreateMaybeMessage<SetProgramRequest>(nullptr);
  }

  SetProgramRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetProgramRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetProgramRequest& from);
  void MergeFrom(const SetProgramRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetProgramRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SetProgramRequest";
  }
  protected:
  explicit SetProgramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kKeyFieldNumber = 1,
    kPersistentFieldNumber = 3,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .hashdb.v1.Fea key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // bool persistent = 3;
  void clear_persistent();
  bool persistent() const;
  void set_persistent(bool value);
  private:
  bool _internal_persistent() const;
  void _internal_set_persistent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.SetProgramRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::hashdb::v1::Fea* key_;
  bool persistent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetProgramRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetProgramRequest) */ {
 public:
  inline GetProgramRequest() : GetProgramRequest(nullptr) {};
  virtual ~GetProgramRequest();

  GetProgramRequest(const GetProgramRequest& from);
  GetProgramRequest(GetProgramRequest&& from) noexcept
    : GetProgramRequest() {
    *this = ::std::move(from);
  }

  inline GetProgramRequest& operator=(const GetProgramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProgramRequest& operator=(GetProgramRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetProgramRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetProgramRequest* internal_default_instance() {
    return reinterpret_cast<const GetProgramRequest*>(
               &_GetProgramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetProgramRequest& a, GetProgramRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProgramRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProgramRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProgramRequest* New() const final {
    return CreateMaybeMessage<GetProgramRequest>(nullptr);
  }

  GetProgramRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProgramRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetProgramRequest& from);
  void MergeFrom(const GetProgramRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProgramRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetProgramRequest";
  }
  protected:
  explicit GetProgramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // .hashdb.v1.Fea key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetProgramRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::hashdb::v1::Fea* key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class LoadDBRequest_InputDbEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadDBRequest_InputDbEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadDBRequest_InputDbEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  LoadDBRequest_InputDbEntry_DoNotUse();
  LoadDBRequest_InputDbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadDBRequest_InputDbEntry_DoNotUse& other);
  static const LoadDBRequest_InputDbEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadDBRequest_InputDbEntry_DoNotUse*>(&_LoadDBRequest_InputDbEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.LoadDBRequest.InputDbEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[5];
  }

  public:
};

// -------------------------------------------------------------------

class LoadDBRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.LoadDBRequest) */ {
 public:
  inline LoadDBRequest() : LoadDBRequest(nullptr) {};
  virtual ~LoadDBRequest();

  LoadDBRequest(const LoadDBRequest& from);
  LoadDBRequest(LoadDBRequest&& from) noexcept
    : LoadDBRequest() {
    *this = ::std::move(from);
  }

  inline LoadDBRequest& operator=(const LoadDBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadDBRequest& operator=(LoadDBRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadDBRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadDBRequest* internal_default_instance() {
    return reinterpret_cast<const LoadDBRequest*>(
               &_LoadDBRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoadDBRequest& a, LoadDBRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadDBRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadDBRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadDBRequest* New() const final {
    return CreateMaybeMessage<LoadDBRequest>(nullptr);
  }

  LoadDBRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadDBRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadDBRequest& from);
  void MergeFrom(const LoadDBRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadDBRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.LoadDBRequest";
  }
  protected:
  explicit LoadDBRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputDbFieldNumber = 1,
    kPersistentFieldNumber = 2,
  };
  // map<string, .hashdb.v1.FeList> input_db = 1;
  int input_db_size() const;
  private:
  int _internal_input_db_size() const;
  public:
  void clear_input_db();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      _internal_input_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      _internal_mutable_input_db();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      input_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      mutable_input_db();

  // bool persistent = 2;
  void clear_persistent();
  bool persistent() const;
  void set_persistent(bool value);
  private:
  bool _internal_persistent() const;
  void _internal_set_persistent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.LoadDBRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      LoadDBRequest_InputDbEntry_DoNotUse,
      std::string, ::hashdb::v1::FeList,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > input_db_;
  bool persistent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class LoadProgramDBRequest_InputProgramDbEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadProgramDBRequest_InputProgramDbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadProgramDBRequest_InputProgramDbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  LoadProgramDBRequest_InputProgramDbEntry_DoNotUse();
  LoadProgramDBRequest_InputProgramDbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadProgramDBRequest_InputProgramDbEntry_DoNotUse& other);
  static const LoadProgramDBRequest_InputProgramDbEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadProgramDBRequest_InputProgramDbEntry_DoNotUse*>(&_LoadProgramDBRequest_InputProgramDbEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.LoadProgramDBRequest.InputProgramDbEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[7];
  }

  public:
};

// -------------------------------------------------------------------

class LoadProgramDBRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.LoadProgramDBRequest) */ {
 public:
  inline LoadProgramDBRequest() : LoadProgramDBRequest(nullptr) {};
  virtual ~LoadProgramDBRequest();

  LoadProgramDBRequest(const LoadProgramDBRequest& from);
  LoadProgramDBRequest(LoadProgramDBRequest&& from) noexcept
    : LoadProgramDBRequest() {
    *this = ::std::move(from);
  }

  inline LoadProgramDBRequest& operator=(const LoadProgramDBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadProgramDBRequest& operator=(LoadProgramDBRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadProgramDBRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadProgramDBRequest* internal_default_instance() {
    return reinterpret_cast<const LoadProgramDBRequest*>(
               &_LoadProgramDBRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LoadProgramDBRequest& a, LoadProgramDBRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadProgramDBRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadProgramDBRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadProgramDBRequest* New() const final {
    return CreateMaybeMessage<LoadProgramDBRequest>(nullptr);
  }

  LoadProgramDBRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadProgramDBRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadProgramDBRequest& from);
  void MergeFrom(const LoadProgramDBRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadProgramDBRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.LoadProgramDBRequest";
  }
  protected:
  explicit LoadProgramDBRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputProgramDbFieldNumber = 1,
    kPersistentFieldNumber = 2,
  };
  // map<string, bytes> input_program_db = 1;
  int input_program_db_size() const;
  private:
  int _internal_input_program_db_size() const;
  public:
  void clear_input_program_db();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_input_program_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_input_program_db();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      input_program_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_input_program_db();

  // bool persistent = 2;
  void clear_persistent();
  bool persistent() const;
  void set_persistent(bool value);
  private:
  bool _internal_persistent() const;
  void _internal_set_persistent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.LoadProgramDBRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      LoadProgramDBRequest_InputProgramDbEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES,
      0 > input_program_db_;
  bool persistent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class FlushRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.FlushRequest) */ {
 public:
  inline FlushRequest() : FlushRequest(nullptr) {};
  virtual ~FlushRequest();

  FlushRequest(const FlushRequest& from);
  FlushRequest(FlushRequest&& from) noexcept
    : FlushRequest() {
    *this = ::std::move(from);
  }

  inline FlushRequest& operator=(const FlushRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushRequest& operator=(FlushRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FlushRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlushRequest* internal_default_instance() {
    return reinterpret_cast<const FlushRequest*>(
               &_FlushRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FlushRequest& a, FlushRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlushRequest* New() const final {
    return CreateMaybeMessage<FlushRequest>(nullptr);
  }

  FlushRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlushRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FlushRequest& from);
  void MergeFrom(const FlushRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.FlushRequest";
  }
  protected:
  explicit FlushRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 1,
    kNewStateRootFieldNumber = 2,
    kPersistenceFieldNumber = 3,
  };
  // string batch_uuid = 1;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  void set_batch_uuid(const std::string& value);
  void set_batch_uuid(std::string&& value);
  void set_batch_uuid(const char* value);
  void set_batch_uuid(const char* value, size_t size);
  std::string* mutable_batch_uuid();
  std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_batch_uuid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_batch_uuid(
      std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // string new_state_root = 2;
  void clear_new_state_root();
  const std::string& new_state_root() const;
  void set_new_state_root(const std::string& value);
  void set_new_state_root(std::string&& value);
  void set_new_state_root(const char* value);
  void set_new_state_root(const char* value, size_t size);
  std::string* mutable_new_state_root();
  std::string* release_new_state_root();
  void set_allocated_new_state_root(std::string* new_state_root);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_new_state_root();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_new_state_root(
      std::string* new_state_root);
  private:
  const std::string& _internal_new_state_root() const;
  void _internal_set_new_state_root(const std::string& value);
  std::string* _internal_mutable_new_state_root();
  public:

  // .hashdb.v1.Persistence persistence = 3;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.FlushRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_state_root_;
  int persistence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SemiFlushRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SemiFlushRequest) */ {
 public:
  inline SemiFlushRequest() : SemiFlushRequest(nullptr) {};
  virtual ~SemiFlushRequest();

  SemiFlushRequest(const SemiFlushRequest& from);
  SemiFlushRequest(SemiFlushRequest&& from) noexcept
    : SemiFlushRequest() {
    *this = ::std::move(from);
  }

  inline SemiFlushRequest& operator=(const SemiFlushRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SemiFlushRequest& operator=(SemiFlushRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SemiFlushRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SemiFlushRequest* internal_default_instance() {
    return reinterpret_cast<const SemiFlushRequest*>(
               &_SemiFlushRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SemiFlushRequest& a, SemiFlushRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SemiFlushRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SemiFlushRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SemiFlushRequest* New() const final {
    return CreateMaybeMessage<SemiFlushRequest>(nullptr);
  }

  SemiFlushRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SemiFlushRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SemiFlushRequest& from);
  void MergeFrom(const SemiFlushRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SemiFlushRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SemiFlushRequest";
  }
  protected:
  explicit SemiFlushRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 1,
    kNewStateRootFieldNumber = 2,
    kPersistenceFieldNumber = 3,
  };
  // string batch_uuid = 1;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  void set_batch_uuid(const std::string& value);
  void set_batch_uuid(std::string&& value);
  void set_batch_uuid(const char* value);
  void set_batch_uuid(const char* value, size_t size);
  std::string* mutable_batch_uuid();
  std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_batch_uuid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_batch_uuid(
      std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // string new_state_root = 2;
  void clear_new_state_root();
  const std::string& new_state_root() const;
  void set_new_state_root(const std::string& value);
  void set_new_state_root(std::string&& value);
  void set_new_state_root(const char* value);
  void set_new_state_root(const char* value, size_t size);
  std::string* mutable_new_state_root();
  std::string* release_new_state_root();
  void set_allocated_new_state_root(std::string* new_state_root);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_new_state_root();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_new_state_root(
      std::string* new_state_root);
  private:
  const std::string& _internal_new_state_root() const;
  void _internal_set_new_state_root(const std::string& value);
  std::string* _internal_mutable_new_state_root();
  public:

  // .hashdb.v1.Persistence persistence = 3;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.SemiFlushRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_state_root_;
  int persistence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetFlushDataRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetFlushDataRequest) */ {
 public:
  inline GetFlushDataRequest() : GetFlushDataRequest(nullptr) {};
  virtual ~GetFlushDataRequest();

  GetFlushDataRequest(const GetFlushDataRequest& from);
  GetFlushDataRequest(GetFlushDataRequest&& from) noexcept
    : GetFlushDataRequest() {
    *this = ::std::move(from);
  }

  inline GetFlushDataRequest& operator=(const GetFlushDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushDataRequest& operator=(GetFlushDataRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetFlushDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetFlushDataRequest* internal_default_instance() {
    return reinterpret_cast<const GetFlushDataRequest*>(
               &_GetFlushDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetFlushDataRequest& a, GetFlushDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushDataRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetFlushDataRequest* New() const final {
    return CreateMaybeMessage<GetFlushDataRequest>(nullptr);
  }

  GetFlushDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetFlushDataRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetFlushDataRequest& from);
  void MergeFrom(const GetFlushDataRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushDataRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetFlushDataRequest";
  }
  protected:
  explicit GetFlushDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlushIdFieldNumber = 1,
  };
  // uint64 flush_id = 1;
  void clear_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 flush_id() const;
  void set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_flush_id() const;
  void _internal_set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetFlushDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 flush_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class ConsolidateStateRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.ConsolidateStateRequest) */ {
 public:
  inline ConsolidateStateRequest() : ConsolidateStateRequest(nullptr) {};
  virtual ~ConsolidateStateRequest();

  ConsolidateStateRequest(const ConsolidateStateRequest& from);
  ConsolidateStateRequest(ConsolidateStateRequest&& from) noexcept
    : ConsolidateStateRequest() {
    *this = ::std::move(from);
  }

  inline ConsolidateStateRequest& operator=(const ConsolidateStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsolidateStateRequest& operator=(ConsolidateStateRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConsolidateStateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConsolidateStateRequest* internal_default_instance() {
    return reinterpret_cast<const ConsolidateStateRequest*>(
               &_ConsolidateStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ConsolidateStateRequest& a, ConsolidateStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsolidateStateRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsolidateStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConsolidateStateRequest* New() const final {
    return CreateMaybeMessage<ConsolidateStateRequest>(nullptr);
  }

  ConsolidateStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConsolidateStateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConsolidateStateRequest& from);
  void MergeFrom(const ConsolidateStateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsolidateStateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.ConsolidateStateRequest";
  }
  protected:
  explicit ConsolidateStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualStateRootFieldNumber = 1,
    kPersistenceFieldNumber = 2,
  };
  // .hashdb.v1.Fea virtual_state_root = 1;
  bool has_virtual_state_root() const;
  private:
  bool _internal_has_virtual_state_root() const;
  public:
  void clear_virtual_state_root();
  const ::hashdb::v1::Fea& virtual_state_root() const;
  ::hashdb::v1::Fea* release_virtual_state_root();
  ::hashdb::v1::Fea* mutable_virtual_state_root();
  void set_allocated_virtual_state_root(::hashdb::v1::Fea* virtual_state_root);
  private:
  const ::hashdb::v1::Fea& _internal_virtual_state_root() const;
  ::hashdb::v1::Fea* _internal_mutable_virtual_state_root();
  public:
  void unsafe_arena_set_allocated_virtual_state_root(
      ::hashdb::v1::Fea* virtual_state_root);
  ::hashdb::v1::Fea* unsafe_arena_release_virtual_state_root();

  // .hashdb.v1.Persistence persistence = 2;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.ConsolidateStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::hashdb::v1::Fea* virtual_state_root_;
  int persistence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class PurgeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.PurgeRequest) */ {
 public:
  inline PurgeRequest() : PurgeRequest(nullptr) {};
  virtual ~PurgeRequest();

  PurgeRequest(const PurgeRequest& from);
  PurgeRequest(PurgeRequest&& from) noexcept
    : PurgeRequest() {
    *this = ::std::move(from);
  }

  inline PurgeRequest& operator=(const PurgeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PurgeRequest& operator=(PurgeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PurgeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PurgeRequest* internal_default_instance() {
    return reinterpret_cast<const PurgeRequest*>(
               &_PurgeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PurgeRequest& a, PurgeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PurgeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PurgeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PurgeRequest* New() const final {
    return CreateMaybeMessage<PurgeRequest>(nullptr);
  }

  PurgeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PurgeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PurgeRequest& from);
  void MergeFrom(const PurgeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PurgeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.PurgeRequest";
  }
  protected:
  explicit PurgeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 1,
    kNewStateRootFieldNumber = 2,
    kPersistenceFieldNumber = 3,
  };
  // string batch_uuid = 1;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  void set_batch_uuid(const std::string& value);
  void set_batch_uuid(std::string&& value);
  void set_batch_uuid(const char* value);
  void set_batch_uuid(const char* value, size_t size);
  std::string* mutable_batch_uuid();
  std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_batch_uuid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_batch_uuid(
      std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // .hashdb.v1.Fea new_state_root = 2;
  bool has_new_state_root() const;
  private:
  bool _internal_has_new_state_root() const;
  public:
  void clear_new_state_root();
  const ::hashdb::v1::Fea& new_state_root() const;
  ::hashdb::v1::Fea* release_new_state_root();
  ::hashdb::v1::Fea* mutable_new_state_root();
  void set_allocated_new_state_root(::hashdb::v1::Fea* new_state_root);
  private:
  const ::hashdb::v1::Fea& _internal_new_state_root() const;
  ::hashdb::v1::Fea* _internal_mutable_new_state_root();
  public:
  void unsafe_arena_set_allocated_new_state_root(
      ::hashdb::v1::Fea* new_state_root);
  ::hashdb::v1::Fea* unsafe_arena_release_new_state_root();

  // .hashdb.v1.Persistence persistence = 3;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.PurgeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
  ::hashdb::v1::Fea* new_state_root_;
  int persistence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class ReadTreeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.ReadTreeRequest) */ {
 public:
  inline ReadTreeRequest() : ReadTreeRequest(nullptr) {};
  virtual ~ReadTreeRequest();

  ReadTreeRequest(const ReadTreeRequest& from);
  ReadTreeRequest(ReadTreeRequest&& from) noexcept
    : ReadTreeRequest() {
    *this = ::std::move(from);
  }

  inline ReadTreeRequest& operator=(const ReadTreeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadTreeRequest& operator=(ReadTreeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReadTreeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadTreeRequest* internal_default_instance() {
    return reinterpret_cast<const ReadTreeRequest*>(
               &_ReadTreeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ReadTreeRequest& a, ReadTreeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadTreeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadTreeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadTreeRequest* New() const final {
    return CreateMaybeMessage<ReadTreeRequest>(nullptr);
  }

  ReadTreeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadTreeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReadTreeRequest& from);
  void MergeFrom(const ReadTreeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadTreeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.ReadTreeRequest";
  }
  protected:
  explicit ReadTreeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kStateRootFieldNumber = 1,
  };
  // repeated .hashdb.v1.Fea keys = 2;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::hashdb::v1::Fea* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::Fea >*
      mutable_keys();
  private:
  const ::hashdb::v1::Fea& _internal_keys(int index) const;
  ::hashdb::v1::Fea* _internal_add_keys();
  public:
  const ::hashdb::v1::Fea& keys(int index) const;
  ::hashdb::v1::Fea* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::Fea >&
      keys() const;

  // .hashdb.v1.Fea state_root = 1;
  bool has_state_root() const;
  private:
  bool _internal_has_state_root() const;
  public:
  void clear_state_root();
  const ::hashdb::v1::Fea& state_root() const;
  ::hashdb::v1::Fea* release_state_root();
  ::hashdb::v1::Fea* mutable_state_root();
  void set_allocated_state_root(::hashdb::v1::Fea* state_root);
  private:
  const ::hashdb::v1::Fea& _internal_state_root() const;
  ::hashdb::v1::Fea* _internal_mutable_state_root();
  public:
  void unsafe_arena_set_allocated_state_root(
      ::hashdb::v1::Fea* state_root);
  ::hashdb::v1::Fea* unsafe_arena_release_state_root();

  // @@protoc_insertion_point(class_scope:hashdb.v1.ReadTreeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::Fea > keys_;
  ::hashdb::v1::Fea* state_root_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class CancelBatchRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.CancelBatchRequest) */ {
 public:
  inline CancelBatchRequest() : CancelBatchRequest(nullptr) {};
  virtual ~CancelBatchRequest();

  CancelBatchRequest(const CancelBatchRequest& from);
  CancelBatchRequest(CancelBatchRequest&& from) noexcept
    : CancelBatchRequest() {
    *this = ::std::move(from);
  }

  inline CancelBatchRequest& operator=(const CancelBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelBatchRequest& operator=(CancelBatchRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CancelBatchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelBatchRequest* internal_default_instance() {
    return reinterpret_cast<const CancelBatchRequest*>(
               &_CancelBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CancelBatchRequest& a, CancelBatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelBatchRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelBatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelBatchRequest* New() const final {
    return CreateMaybeMessage<CancelBatchRequest>(nullptr);
  }

  CancelBatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelBatchRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CancelBatchRequest& from);
  void MergeFrom(const CancelBatchRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelBatchRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.CancelBatchRequest";
  }
  protected:
  explicit CancelBatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 1,
  };
  // string batch_uuid = 1;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  void set_batch_uuid(const std::string& value);
  void set_batch_uuid(std::string&& value);
  void set_batch_uuid(const char* value);
  void set_batch_uuid(const char* value, size_t size);
  std::string* mutable_batch_uuid();
  std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_batch_uuid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_batch_uuid(
      std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.CancelBatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetResponse_SiblingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_SiblingsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_SiblingsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SetResponse_SiblingsEntry_DoNotUse();
  SetResponse_SiblingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetResponse_SiblingsEntry_DoNotUse& other);
  static const SetResponse_SiblingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetResponse_SiblingsEntry_DoNotUse*>(&_SetResponse_SiblingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[16];
  }

  public:
};

// -------------------------------------------------------------------

class SetResponse_DbReadLogEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SetResponse_DbReadLogEntry_DoNotUse();
  SetResponse_DbReadLogEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetResponse_DbReadLogEntry_DoNotUse& other);
  static const SetResponse_DbReadLogEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetResponse_DbReadLogEntry_DoNotUse*>(&_SetResponse_DbReadLogEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.SetResponse.DbReadLogEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[17];
  }

  public:
};

// -------------------------------------------------------------------

class SetResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetResponse) */ {
 public:
  inline SetResponse() : SetResponse(nullptr) {};
  virtual ~SetResponse();

  SetResponse(const SetResponse& from);
  SetResponse(SetResponse&& from) noexcept
    : SetResponse() {
    *this = ::std::move(from);
  }

  inline SetResponse& operator=(const SetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetResponse& operator=(SetResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetResponse* internal_default_instance() {
    return reinterpret_cast<const SetResponse*>(
               &_SetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SetResponse& a, SetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetResponse* New() const final {
    return CreateMaybeMessage<SetResponse>(nullptr);
  }

  SetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetResponse& from);
  void MergeFrom(const SetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SetResponse";
  }
  protected:
  explicit SetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSiblingsFieldNumber = 4,
    kDbReadLogFieldNumber = 12,
    kInsValueFieldNumber = 6,
    kOldValueFieldNumber = 8,
    kNewValueFieldNumber = 9,
    kModeFieldNumber = 10,
    kOldRootFieldNumber = 1,
    kNewRootFieldNumber = 2,
    kKeyFieldNumber = 3,
    kInsKeyFieldNumber = 5,
    kResultFieldNumber = 13,
    kProofHashCounterFieldNumber = 11,
    kIsOld0FieldNumber = 7,
  };
  // map<uint64, .hashdb.v1.SiblingList> siblings = 4;
  int siblings_size() const;
  private:
  int _internal_siblings_size() const;
  public:
  void clear_siblings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
      _internal_siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
      _internal_mutable_siblings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
      siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
      mutable_siblings();

  // map<string, .hashdb.v1.FeList> db_read_log = 12;
  int db_read_log_size() const;
  private:
  int _internal_db_read_log_size() const;
  public:
  void clear_db_read_log();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      _internal_db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      _internal_mutable_db_read_log();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      mutable_db_read_log();

  // string ins_value = 6;
  void clear_ins_value();
  const std::string& ins_value() const;
  void set_ins_value(const std::string& value);
  void set_ins_value(std::string&& value);
  void set_ins_value(const char* value);
  void set_ins_value(const char* value, size_t size);
  std::string* mutable_ins_value();
  std::string* release_ins_value();
  void set_allocated_ins_value(std::string* ins_value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ins_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ins_value(
      std::string* ins_value);
  private:
  const std::string& _internal_ins_value() const;
  void _internal_set_ins_value(const std::string& value);
  std::string* _internal_mutable_ins_value();
  public:

  // string old_value = 8;
  void clear_old_value();
  const std::string& old_value() const;
  void set_old_value(const std::string& value);
  void set_old_value(std::string&& value);
  void set_old_value(const char* value);
  void set_old_value(const char* value, size_t size);
  std::string* mutable_old_value();
  std::string* release_old_value();
  void set_allocated_old_value(std::string* old_value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_old_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_old_value(
      std::string* old_value);
  private:
  const std::string& _internal_old_value() const;
  void _internal_set_old_value(const std::string& value);
  std::string* _internal_mutable_old_value();
  public:

  // string new_value = 9;
  void clear_new_value();
  const std::string& new_value() const;
  void set_new_value(const std::string& value);
  void set_new_value(std::string&& value);
  void set_new_value(const char* value);
  void set_new_value(const char* value, size_t size);
  std::string* mutable_new_value();
  std::string* release_new_value();
  void set_allocated_new_value(std::string* new_value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_new_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_new_value(
      std::string* new_value);
  private:
  const std::string& _internal_new_value() const;
  void _internal_set_new_value(const std::string& value);
  std::string* _internal_mutable_new_value();
  public:

  // string mode = 10;
  void clear_mode();
  const std::string& mode() const;
  void set_mode(const std::string& value);
  void set_mode(std::string&& value);
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  std::string* mutable_mode();
  std::string* release_mode();
  void set_allocated_mode(std::string* mode);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_mode();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_mode(
      std::string* mode);
  private:
  const std::string& _internal_mode() const;
  void _internal_set_mode(const std::string& value);
  std::string* _internal_mutable_mode();
  public:

  // .hashdb.v1.Fea old_root = 1;
  bool has_old_root() const;
  private:
  bool _internal_has_old_root() const;
  public:
  void clear_old_root();
  const ::hashdb::v1::Fea& old_root() const;
  ::hashdb::v1::Fea* release_old_root();
  ::hashdb::v1::Fea* mutable_old_root();
  void set_allocated_old_root(::hashdb::v1::Fea* old_root);
  private:
  const ::hashdb::v1::Fea& _internal_old_root() const;
  ::hashdb::v1::Fea* _internal_mutable_old_root();
  public:
  void unsafe_arena_set_allocated_old_root(
      ::hashdb::v1::Fea* old_root);
  ::hashdb::v1::Fea* unsafe_arena_release_old_root();

  // .hashdb.v1.Fea new_root = 2;
  bool has_new_root() const;
  private:
  bool _internal_has_new_root() const;
  public:
  void clear_new_root();
  const ::hashdb::v1::Fea& new_root() const;
  ::hashdb::v1::Fea* release_new_root();
  ::hashdb::v1::Fea* mutable_new_root();
  void set_allocated_new_root(::hashdb::v1::Fea* new_root);
  private:
  const ::hashdb::v1::Fea& _internal_new_root() const;
  ::hashdb::v1::Fea* _internal_mutable_new_root();
  public:
  void unsafe_arena_set_allocated_new_root(
      ::hashdb::v1::Fea* new_root);
  ::hashdb::v1::Fea* unsafe_arena_release_new_root();

  // .hashdb.v1.Fea key = 3;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // .hashdb.v1.Fea ins_key = 5;
  bool has_ins_key() const;
  private:
  bool _internal_has_ins_key() const;
  public:
  void clear_ins_key();
  const ::hashdb::v1::Fea& ins_key() const;
  ::hashdb::v1::Fea* release_ins_key();
  ::hashdb::v1::Fea* mutable_ins_key();
  void set_allocated_ins_key(::hashdb::v1::Fea* ins_key);
  private:
  const ::hashdb::v1::Fea& _internal_ins_key() const;
  ::hashdb::v1::Fea* _internal_mutable_ins_key();
  public:
  void unsafe_arena_set_allocated_ins_key(
      ::hashdb::v1::Fea* ins_key);
  ::hashdb::v1::Fea* unsafe_arena_release_ins_key();

  // .hashdb.v1.ResultCode result = 13;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // uint64 proof_hash_counter = 11;
  void clear_proof_hash_counter();
  ::PROTOBUF_NAMESPACE_ID::uint64 proof_hash_counter() const;
  void set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_proof_hash_counter() const;
  void _internal_set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool is_old0 = 7;
  void clear_is_old0();
  bool is_old0() const;
  void set_is_old0(bool value);
  private:
  bool _internal_is_old0() const;
  void _internal_set_is_old0(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.SetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SetResponse_SiblingsEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > siblings_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SetResponse_DbReadLogEntry_DoNotUse,
      std::string, ::hashdb::v1::FeList,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > db_read_log_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ins_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mode_;
  ::hashdb::v1::Fea* old_root_;
  ::hashdb::v1::Fea* new_root_;
  ::hashdb::v1::Fea* key_;
  ::hashdb::v1::Fea* ins_key_;
  ::hashdb::v1::ResultCode* result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 proof_hash_counter_;
  bool is_old0_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetResponse_SiblingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_SiblingsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_SiblingsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  GetResponse_SiblingsEntry_DoNotUse();
  GetResponse_SiblingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetResponse_SiblingsEntry_DoNotUse& other);
  static const GetResponse_SiblingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetResponse_SiblingsEntry_DoNotUse*>(&_GetResponse_SiblingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[19];
  }

  public:
};

// -------------------------------------------------------------------

class GetResponse_DbReadLogEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  GetResponse_DbReadLogEntry_DoNotUse();
  GetResponse_DbReadLogEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetResponse_DbReadLogEntry_DoNotUse& other);
  static const GetResponse_DbReadLogEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetResponse_DbReadLogEntry_DoNotUse*>(&_GetResponse_DbReadLogEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetResponse.DbReadLogEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[20];
  }

  public:
};

// -------------------------------------------------------------------

class GetResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetResponse) */ {
 public:
  inline GetResponse() : GetResponse(nullptr) {};
  virtual ~GetResponse();

  GetResponse(const GetResponse& from);
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResponse* New() const final {
    return CreateMaybeMessage<GetResponse>(nullptr);
  }

  GetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetResponse";
  }
  protected:
  explicit GetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSiblingsFieldNumber = 3,
    kDbReadLogFieldNumber = 9,
    kInsValueFieldNumber = 5,
    kValueFieldNumber = 7,
    kRootFieldNumber = 1,
    kKeyFieldNumber = 2,
    kInsKeyFieldNumber = 4,
    kResultFieldNumber = 10,
    kProofHashCounterFieldNumber = 8,
    kIsOld0FieldNumber = 6,
  };
  // map<uint64, .hashdb.v1.SiblingList> siblings = 3;
  int siblings_size() const;
  private:
  int _internal_siblings_size() const;
  public:
  void clear_siblings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
      _internal_siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
      _internal_mutable_siblings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
      siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
      mutable_siblings();

  // map<string, .hashdb.v1.FeList> db_read_log = 9;
  int db_read_log_size() const;
  private:
  int _internal_db_read_log_size() const;
  public:
  void clear_db_read_log();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      _internal_db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      _internal_mutable_db_read_log();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      mutable_db_read_log();

  // string ins_value = 5;
  void clear_ins_value();
  const std::string& ins_value() const;
  void set_ins_value(const std::string& value);
  void set_ins_value(std::string&& value);
  void set_ins_value(const char* value);
  void set_ins_value(const char* value, size_t size);
  std::string* mutable_ins_value();
  std::string* release_ins_value();
  void set_allocated_ins_value(std::string* ins_value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ins_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ins_value(
      std::string* ins_value);
  private:
  const std::string& _internal_ins_value() const;
  void _internal_set_ins_value(const std::string& value);
  std::string* _internal_mutable_ins_value();
  public:

  // string value = 7;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .hashdb.v1.Fea root = 1;
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::hashdb::v1::Fea& root() const;
  ::hashdb::v1::Fea* release_root();
  ::hashdb::v1::Fea* mutable_root();
  void set_allocated_root(::hashdb::v1::Fea* root);
  private:
  const ::hashdb::v1::Fea& _internal_root() const;
  ::hashdb::v1::Fea* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::hashdb::v1::Fea* root);
  ::hashdb::v1::Fea* unsafe_arena_release_root();

  // .hashdb.v1.Fea key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // .hashdb.v1.Fea ins_key = 4;
  bool has_ins_key() const;
  private:
  bool _internal_has_ins_key() const;
  public:
  void clear_ins_key();
  const ::hashdb::v1::Fea& ins_key() const;
  ::hashdb::v1::Fea* release_ins_key();
  ::hashdb::v1::Fea* mutable_ins_key();
  void set_allocated_ins_key(::hashdb::v1::Fea* ins_key);
  private:
  const ::hashdb::v1::Fea& _internal_ins_key() const;
  ::hashdb::v1::Fea* _internal_mutable_ins_key();
  public:
  void unsafe_arena_set_allocated_ins_key(
      ::hashdb::v1::Fea* ins_key);
  ::hashdb::v1::Fea* unsafe_arena_release_ins_key();

  // .hashdb.v1.ResultCode result = 10;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // uint64 proof_hash_counter = 8;
  void clear_proof_hash_counter();
  ::PROTOBUF_NAMESPACE_ID::uint64 proof_hash_counter() const;
  void set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_proof_hash_counter() const;
  void _internal_set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool is_old0 = 6;
  void clear_is_old0();
  bool is_old0() const;
  void set_is_old0(bool value);
  private:
  bool _internal_is_old0() const;
  void _internal_set_is_old0(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetResponse_SiblingsEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > siblings_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetResponse_DbReadLogEntry_DoNotUse,
      std::string, ::hashdb::v1::FeList,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > db_read_log_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ins_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::hashdb::v1::Fea* root_;
  ::hashdb::v1::Fea* key_;
  ::hashdb::v1::Fea* ins_key_;
  ::hashdb::v1::ResultCode* result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 proof_hash_counter_;
  bool is_old0_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetProgramResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetProgramResponse) */ {
 public:
  inline SetProgramResponse() : SetProgramResponse(nullptr) {};
  virtual ~SetProgramResponse();

  SetProgramResponse(const SetProgramResponse& from);
  SetProgramResponse(SetProgramResponse&& from) noexcept
    : SetProgramResponse() {
    *this = ::std::move(from);
  }

  inline SetProgramResponse& operator=(const SetProgramResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetProgramResponse& operator=(SetProgramResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetProgramResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetProgramResponse* internal_default_instance() {
    return reinterpret_cast<const SetProgramResponse*>(
               &_SetProgramResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SetProgramResponse& a, SetProgramResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetProgramResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetProgramResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetProgramResponse* New() const final {
    return CreateMaybeMessage<SetProgramResponse>(nullptr);
  }

  SetProgramResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetProgramResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetProgramResponse& from);
  void MergeFrom(const SetProgramResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetProgramResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SetProgramResponse";
  }
  protected:
  explicit SetProgramResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .hashdb.v1.ResultCode result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.SetProgramResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::hashdb::v1::ResultCode* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetProgramResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetProgramResponse) */ {
 public:
  inline GetProgramResponse() : GetProgramResponse(nullptr) {};
  virtual ~GetProgramResponse();

  GetProgramResponse(const GetProgramResponse& from);
  GetProgramResponse(GetProgramResponse&& from) noexcept
    : GetProgramResponse() {
    *this = ::std::move(from);
  }

  inline GetProgramResponse& operator=(const GetProgramResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProgramResponse& operator=(GetProgramResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetProgramResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetProgramResponse* internal_default_instance() {
    return reinterpret_cast<const GetProgramResponse*>(
               &_GetProgramResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetProgramResponse& a, GetProgramResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProgramResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProgramResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProgramResponse* New() const final {
    return CreateMaybeMessage<GetProgramResponse>(nullptr);
  }

  GetProgramResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProgramResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetProgramResponse& from);
  void MergeFrom(const GetProgramResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProgramResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetProgramResponse";
  }
  protected:
  explicit GetProgramResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .hashdb.v1.ResultCode result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetProgramResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::hashdb::v1::ResultCode* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class FlushResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.FlushResponse) */ {
 public:
  inline FlushResponse() : FlushResponse(nullptr) {};
  virtual ~FlushResponse();

  FlushResponse(const FlushResponse& from);
  FlushResponse(FlushResponse&& from) noexcept
    : FlushResponse() {
    *this = ::std::move(from);
  }

  inline FlushResponse& operator=(const FlushResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushResponse& operator=(FlushResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FlushResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlushResponse* internal_default_instance() {
    return reinterpret_cast<const FlushResponse*>(
               &_FlushResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(FlushResponse& a, FlushResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlushResponse* New() const final {
    return CreateMaybeMessage<FlushResponse>(nullptr);
  }

  FlushResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlushResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FlushResponse& from);
  void MergeFrom(const FlushResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.FlushResponse";
  }
  protected:
  explicit FlushResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 3,
    kFlushIdFieldNumber = 1,
    kStoredFlushIdFieldNumber = 2,
  };
  // .hashdb.v1.ResultCode result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // uint64 flush_id = 1;
  void clear_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 flush_id() const;
  void set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_flush_id() const;
  void _internal_set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 stored_flush_id = 2;
  void clear_stored_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id() const;
  void set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.FlushResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::hashdb::v1::ResultCode* result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 flush_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetFlushStatusResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetFlushStatusResponse) */ {
 public:
  inline GetFlushStatusResponse() : GetFlushStatusResponse(nullptr) {};
  virtual ~GetFlushStatusResponse();

  GetFlushStatusResponse(const GetFlushStatusResponse& from);
  GetFlushStatusResponse(GetFlushStatusResponse&& from) noexcept
    : GetFlushStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetFlushStatusResponse& operator=(const GetFlushStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushStatusResponse& operator=(GetFlushStatusResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetFlushStatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetFlushStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlushStatusResponse*>(
               &_GetFlushStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetFlushStatusResponse& a, GetFlushStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushStatusResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetFlushStatusResponse* New() const final {
    return CreateMaybeMessage<GetFlushStatusResponse>(nullptr);
  }

  GetFlushStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetFlushStatusResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetFlushStatusResponse& from);
  void MergeFrom(const GetFlushStatusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushStatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetFlushStatusResponse";
  }
  protected:
  explicit GetFlushStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProverIdFieldNumber = 8,
    kStoredFlushIdFieldNumber = 1,
    kStoringFlushIdFieldNumber = 2,
    kLastFlushIdFieldNumber = 3,
    kPendingToFlushNodesFieldNumber = 4,
    kPendingToFlushProgramFieldNumber = 5,
    kStoringNodesFieldNumber = 6,
    kStoringProgramFieldNumber = 7,
  };
  // string prover_id = 8;
  void clear_prover_id();
  const std::string& prover_id() const;
  void set_prover_id(const std::string& value);
  void set_prover_id(std::string&& value);
  void set_prover_id(const char* value);
  void set_prover_id(const char* value, size_t size);
  std::string* mutable_prover_id();
  std::string* release_prover_id();
  void set_allocated_prover_id(std::string* prover_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_prover_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_prover_id(
      std::string* prover_id);
  private:
  const std::string& _internal_prover_id() const;
  void _internal_set_prover_id(const std::string& value);
  std::string* _internal_mutable_prover_id();
  public:

  // uint64 stored_flush_id = 1;
  void clear_stored_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id() const;
  void set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 storing_flush_id = 2;
  void clear_storing_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 storing_flush_id() const;
  void set_storing_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_storing_flush_id() const;
  void _internal_set_storing_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 last_flush_id = 3;
  void clear_last_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_flush_id() const;
  void set_last_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_flush_id() const;
  void _internal_set_last_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 pending_to_flush_nodes = 4;
  void clear_pending_to_flush_nodes();
  ::PROTOBUF_NAMESPACE_ID::uint64 pending_to_flush_nodes() const;
  void set_pending_to_flush_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_pending_to_flush_nodes() const;
  void _internal_set_pending_to_flush_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 pending_to_flush_program = 5;
  void clear_pending_to_flush_program();
  ::PROTOBUF_NAMESPACE_ID::uint64 pending_to_flush_program() const;
  void set_pending_to_flush_program(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_pending_to_flush_program() const;
  void _internal_set_pending_to_flush_program(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 storing_nodes = 6;
  void clear_storing_nodes();
  ::PROTOBUF_NAMESPACE_ID::uint64 storing_nodes() const;
  void set_storing_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_storing_nodes() const;
  void _internal_set_storing_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 storing_program = 7;
  void clear_storing_program();
  ::PROTOBUF_NAMESPACE_ID::uint64 storing_program() const;
  void set_storing_program(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_storing_program() const;
  void _internal_set_storing_program(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetFlushStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 storing_flush_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_flush_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 pending_to_flush_nodes_;
  ::PROTOBUF_NAMESPACE_ID::uint64 pending_to_flush_program_;
  ::PROTOBUF_NAMESPACE_ID::uint64 storing_nodes_;
  ::PROTOBUF_NAMESPACE_ID::uint64 storing_program_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetFlushDataResponse_NodesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_NodesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_NodesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  GetFlushDataResponse_NodesEntry_DoNotUse();
  GetFlushDataResponse_NodesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetFlushDataResponse_NodesEntry_DoNotUse& other);
  static const GetFlushDataResponse_NodesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetFlushDataResponse_NodesEntry_DoNotUse*>(&_GetFlushDataResponse_NodesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.NodesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.NodesEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[26];
  }

  public:
};

// -------------------------------------------------------------------

class GetFlushDataResponse_ProgramEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_ProgramEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_ProgramEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  GetFlushDataResponse_ProgramEntry_DoNotUse();
  GetFlushDataResponse_ProgramEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetFlushDataResponse_ProgramEntry_DoNotUse& other);
  static const GetFlushDataResponse_ProgramEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetFlushDataResponse_ProgramEntry_DoNotUse*>(&_GetFlushDataResponse_ProgramEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.ProgramEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.ProgramEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[27];
  }

  public:
};

// -------------------------------------------------------------------

class GetFlushDataResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetFlushDataResponse) */ {
 public:
  inline GetFlushDataResponse() : GetFlushDataResponse(nullptr) {};
  virtual ~GetFlushDataResponse();

  GetFlushDataResponse(const GetFlushDataResponse& from);
  GetFlushDataResponse(GetFlushDataResponse&& from) noexcept
    : GetFlushDataResponse() {
    *this = ::std::move(from);
  }

  inline GetFlushDataResponse& operator=(const GetFlushDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushDataResponse& operator=(GetFlushDataResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetFlushDataResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetFlushDataResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlushDataResponse*>(
               &_GetFlushDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GetFlushDataResponse& a, GetFlushDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushDataResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetFlushDataResponse* New() const final {
    return CreateMaybeMessage<GetFlushDataResponse>(nullptr);
  }

  GetFlushDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetFlushDataResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetFlushDataResponse& from);
  void MergeFrom(const GetFlushDataResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushDataResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetFlushDataResponse";
  }
  protected:
  explicit GetFlushDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 2,
    kProgramFieldNumber = 3,
    kNodesStateRootFieldNumber = 4,
    kResultFieldNumber = 5,
    kStoredFlushIdFieldNumber = 1,
  };
  // map<string, string> nodes = 2;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_nodes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_nodes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      nodes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_nodes();

  // map<string, string> program = 3;
  int program_size() const;
  private:
  int _internal_program_size() const;
  public:
  void clear_program();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_program() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_program();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      program() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_program();

  // string nodes_state_root = 4;
  void clear_nodes_state_root();
  const std::string& nodes_state_root() const;
  void set_nodes_state_root(const std::string& value);
  void set_nodes_state_root(std::string&& value);
  void set_nodes_state_root(const char* value);
  void set_nodes_state_root(const char* value, size_t size);
  std::string* mutable_nodes_state_root();
  std::string* release_nodes_state_root();
  void set_allocated_nodes_state_root(std::string* nodes_state_root);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_nodes_state_root();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nodes_state_root(
      std::string* nodes_state_root);
  private:
  const std::string& _internal_nodes_state_root() const;
  void _internal_set_nodes_state_root(const std::string& value);
  std::string* _internal_mutable_nodes_state_root();
  public:

  // .hashdb.v1.ResultCode result = 5;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // uint64 stored_flush_id = 1;
  void clear_stored_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id() const;
  void set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetFlushDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetFlushDataResponse_NodesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > nodes_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetFlushDataResponse_ProgramEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > program_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodes_state_root_;
  ::hashdb::v1::ResultCode* result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class ConsolidateStateResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.ConsolidateStateResponse) */ {
 public:
  inline ConsolidateStateResponse() : ConsolidateStateResponse(nullptr) {};
  virtual ~ConsolidateStateResponse();

  ConsolidateStateResponse(const ConsolidateStateResponse& from);
  ConsolidateStateResponse(ConsolidateStateResponse&& from) noexcept
    : ConsolidateStateResponse() {
    *this = ::std::move(from);
  }

  inline ConsolidateStateResponse& operator=(const ConsolidateStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsolidateStateResponse& operator=(ConsolidateStateResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConsolidateStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConsolidateStateResponse* internal_default_instance() {
    return reinterpret_cast<const ConsolidateStateResponse*>(
               &_ConsolidateStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ConsolidateStateResponse& a, ConsolidateStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsolidateStateResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsolidateStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConsolidateStateResponse* New() const final {
    return CreateMaybeMessage<ConsolidateStateResponse>(nullptr);
  }

  ConsolidateStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConsolidateStateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConsolidateStateResponse& from);
  void MergeFrom(const ConsolidateStateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsolidateStateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.ConsolidateStateResponse";
  }
  protected:
  explicit ConsolidateStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsolidatedStateRootFieldNumber = 1,
    kResultFieldNumber = 4,
    kFlushIdFieldNumber = 2,
    kStoredFlushIdFieldNumber = 3,
  };
  // .hashdb.v1.Fea consolidated_state_root = 1;
  bool has_consolidated_state_root() const;
  private:
  bool _internal_has_consolidated_state_root() const;
  public:
  void clear_consolidated_state_root();
  const ::hashdb::v1::Fea& consolidated_state_root() const;
  ::hashdb::v1::Fea* release_consolidated_state_root();
  ::hashdb::v1::Fea* mutable_consolidated_state_root();
  void set_allocated_consolidated_state_root(::hashdb::v1::Fea* consolidated_state_root);
  private:
  const ::hashdb::v1::Fea& _internal_consolidated_state_root() const;
  ::hashdb::v1::Fea* _internal_mutable_consolidated_state_root();
  public:
  void unsafe_arena_set_allocated_consolidated_state_root(
      ::hashdb::v1::Fea* consolidated_state_root);
  ::hashdb::v1::Fea* unsafe_arena_release_consolidated_state_root();

  // .hashdb.v1.ResultCode result = 4;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // uint64 flush_id = 2;
  void clear_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 flush_id() const;
  void set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_flush_id() const;
  void _internal_set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 stored_flush_id = 3;
  void clear_stored_flush_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id() const;
  void set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.ConsolidateStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::hashdb::v1::Fea* consolidated_state_root_;
  ::hashdb::v1::ResultCode* result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 flush_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stored_flush_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class PurgeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.PurgeResponse) */ {
 public:
  inline PurgeResponse() : PurgeResponse(nullptr) {};
  virtual ~PurgeResponse();

  PurgeResponse(const PurgeResponse& from);
  PurgeResponse(PurgeResponse&& from) noexcept
    : PurgeResponse() {
    *this = ::std::move(from);
  }

  inline PurgeResponse& operator=(const PurgeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PurgeResponse& operator=(PurgeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PurgeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PurgeResponse* internal_default_instance() {
    return reinterpret_cast<const PurgeResponse*>(
               &_PurgeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(PurgeResponse& a, PurgeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PurgeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PurgeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PurgeResponse* New() const final {
    return CreateMaybeMessage<PurgeResponse>(nullptr);
  }

  PurgeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PurgeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PurgeResponse& from);
  void MergeFrom(const PurgeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PurgeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.PurgeResponse";
  }
  protected:
  explicit PurgeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .hashdb.v1.ResultCode result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.PurgeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::hashdb::v1::ResultCode* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class ReadTreeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.ReadTreeResponse) */ {
 public:
  inline ReadTreeResponse() : ReadTreeResponse(nullptr) {};
  virtual ~ReadTreeResponse();

  ReadTreeResponse(const ReadTreeResponse& from);
  ReadTreeResponse(ReadTreeResponse&& from) noexcept
    : ReadTreeResponse() {
    *this = ::std::move(from);
  }

  inline ReadTreeResponse& operator=(const ReadTreeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadTreeResponse& operator=(ReadTreeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReadTreeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadTreeResponse* internal_default_instance() {
    return reinterpret_cast<const ReadTreeResponse*>(
               &_ReadTreeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ReadTreeResponse& a, ReadTreeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadTreeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadTreeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadTreeResponse* New() const final {
    return CreateMaybeMessage<ReadTreeResponse>(nullptr);
  }

  ReadTreeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadTreeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReadTreeResponse& from);
  void MergeFrom(const ReadTreeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadTreeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.ReadTreeResponse";
  }
  protected:
  explicit ReadTreeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyValueFieldNumber = 1,
    kHashValueFieldNumber = 2,
    kResultFieldNumber = 3,
  };
  // repeated .hashdb.v1.KeyValue key_value = 1;
  int key_value_size() const;
  private:
  int _internal_key_value_size() const;
  public:
  void clear_key_value();
  ::hashdb::v1::KeyValue* mutable_key_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::KeyValue >*
      mutable_key_value();
  private:
  const ::hashdb::v1::KeyValue& _internal_key_value(int index) const;
  ::hashdb::v1::KeyValue* _internal_add_key_value();
  public:
  const ::hashdb::v1::KeyValue& key_value(int index) const;
  ::hashdb::v1::KeyValue* add_key_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::KeyValue >&
      key_value() const;

  // repeated .hashdb.v1.HashValueGL hash_value = 2;
  int hash_value_size() const;
  private:
  int _internal_hash_value_size() const;
  public:
  void clear_hash_value();
  ::hashdb::v1::HashValueGL* mutable_hash_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::HashValueGL >*
      mutable_hash_value();
  private:
  const ::hashdb::v1::HashValueGL& _internal_hash_value(int index) const;
  ::hashdb::v1::HashValueGL* _internal_add_hash_value();
  public:
  const ::hashdb::v1::HashValueGL& hash_value(int index) const;
  ::hashdb::v1::HashValueGL* add_hash_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::HashValueGL >&
      hash_value() const;

  // .hashdb.v1.ResultCode result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.ReadTreeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::KeyValue > key_value_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::HashValueGL > hash_value_;
  ::hashdb::v1::ResultCode* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class CancelBatchResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.CancelBatchResponse) */ {
 public:
  inline CancelBatchResponse() : CancelBatchResponse(nullptr) {};
  virtual ~CancelBatchResponse();

  CancelBatchResponse(const CancelBatchResponse& from);
  CancelBatchResponse(CancelBatchResponse&& from) noexcept
    : CancelBatchResponse() {
    *this = ::std::move(from);
  }

  inline CancelBatchResponse& operator=(const CancelBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelBatchResponse& operator=(CancelBatchResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CancelBatchResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelBatchResponse* internal_default_instance() {
    return reinterpret_cast<const CancelBatchResponse*>(
               &_CancelBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CancelBatchResponse& a, CancelBatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelBatchResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelBatchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelBatchResponse* New() const final {
    return CreateMaybeMessage<CancelBatchResponse>(nullptr);
  }

  CancelBatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelBatchResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CancelBatchResponse& from);
  void MergeFrom(const CancelBatchResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelBatchResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.CancelBatchResponse";
  }
  protected:
  explicit CancelBatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .hashdb.v1.ResultCode result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.CancelBatchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::hashdb::v1::ResultCode* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class Fea PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.Fea) */ {
 public:
  inline Fea() : Fea(nullptr) {};
  virtual ~Fea();

  Fea(const Fea& from);
  Fea(Fea&& from) noexcept
    : Fea() {
    *this = ::std::move(from);
  }

  inline Fea& operator=(const Fea& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fea& operator=(Fea&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Fea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fea* internal_default_instance() {
    return reinterpret_cast<const Fea*>(
               &_Fea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Fea& a, Fea& b) {
    a.Swap(&b);
  }
  inline void Swap(Fea* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fea* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fea* New() const final {
    return CreateMaybeMessage<Fea>(nullptr);
  }

  Fea* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fea>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Fea& from);
  void MergeFrom(const Fea& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fea* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.Fea";
  }
  protected:
  explicit Fea(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFe0FieldNumber = 1,
    kFe1FieldNumber = 2,
    kFe2FieldNumber = 3,
    kFe3FieldNumber = 4,
  };
  // uint64 fe0 = 1;
  void clear_fe0();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe0() const;
  void set_fe0(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe0() const;
  void _internal_set_fe0(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe1 = 2;
  void clear_fe1();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe1() const;
  void set_fe1(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe1() const;
  void _internal_set_fe1(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe2 = 3;
  void clear_fe2();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe2() const;
  void set_fe2(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe2() const;
  void _internal_set_fe2(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe3 = 4;
  void clear_fe3();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe3() const;
  void set_fe3(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe3() const;
  void _internal_set_fe3(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.Fea)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe0_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe1_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe2_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe3_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class Fea12 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.Fea12) */ {
 public:
  inline Fea12() : Fea12(nullptr) {};
  virtual ~Fea12();

  Fea12(const Fea12& from);
  Fea12(Fea12&& from) noexcept
    : Fea12() {
    *this = ::std::move(from);
  }

  inline Fea12& operator=(const Fea12& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fea12& operator=(Fea12&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Fea12& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fea12* internal_default_instance() {
    return reinterpret_cast<const Fea12*>(
               &_Fea12_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Fea12& a, Fea12& b) {
    a.Swap(&b);
  }
  inline void Swap(Fea12* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fea12* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fea12* New() const final {
    return CreateMaybeMessage<Fea12>(nullptr);
  }

  Fea12* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fea12>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Fea12& from);
  void MergeFrom(const Fea12& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fea12* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.Fea12";
  }
  protected:
  explicit Fea12(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFe0FieldNumber = 1,
    kFe1FieldNumber = 2,
    kFe2FieldNumber = 3,
    kFe3FieldNumber = 4,
    kFe4FieldNumber = 5,
    kFe5FieldNumber = 6,
    kFe6FieldNumber = 7,
    kFe7FieldNumber = 8,
    kFe8FieldNumber = 9,
    kFe9FieldNumber = 10,
    kFe10FieldNumber = 11,
    kFe11FieldNumber = 12,
  };
  // uint64 fe0 = 1;
  void clear_fe0();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe0() const;
  void set_fe0(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe0() const;
  void _internal_set_fe0(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe1 = 2;
  void clear_fe1();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe1() const;
  void set_fe1(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe1() const;
  void _internal_set_fe1(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe2 = 3;
  void clear_fe2();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe2() const;
  void set_fe2(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe2() const;
  void _internal_set_fe2(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe3 = 4;
  void clear_fe3();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe3() const;
  void set_fe3(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe3() const;
  void _internal_set_fe3(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe4 = 5;
  void clear_fe4();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe4() const;
  void set_fe4(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe4() const;
  void _internal_set_fe4(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe5 = 6;
  void clear_fe5();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe5() const;
  void set_fe5(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe5() const;
  void _internal_set_fe5(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe6 = 7;
  void clear_fe6();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe6() const;
  void set_fe6(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe6() const;
  void _internal_set_fe6(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe7 = 8;
  void clear_fe7();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe7() const;
  void set_fe7(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe7() const;
  void _internal_set_fe7(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe8 = 9;
  void clear_fe8();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe8() const;
  void set_fe8(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe8() const;
  void _internal_set_fe8(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe9 = 10;
  void clear_fe9();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe9() const;
  void set_fe9(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe9() const;
  void _internal_set_fe9(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe10 = 11;
  void clear_fe10();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe10() const;
  void set_fe10(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe10() const;
  void _internal_set_fe10(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fe11 = 12;
  void clear_fe11();
  ::PROTOBUF_NAMESPACE_ID::uint64 fe11() const;
  void set_fe11(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe11() const;
  void _internal_set_fe11(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.Fea12)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe0_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe1_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe2_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe3_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe4_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe5_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe6_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe7_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe8_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe9_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe10_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fe11_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class HashValueGL PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.HashValueGL) */ {
 public:
  inline HashValueGL() : HashValueGL(nullptr) {};
  virtual ~HashValueGL();

  HashValueGL(const HashValueGL& from);
  HashValueGL(HashValueGL&& from) noexcept
    : HashValueGL() {
    *this = ::std::move(from);
  }

  inline HashValueGL& operator=(const HashValueGL& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashValueGL& operator=(HashValueGL&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HashValueGL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HashValueGL* internal_default_instance() {
    return reinterpret_cast<const HashValueGL*>(
               &_HashValueGL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(HashValueGL& a, HashValueGL& b) {
    a.Swap(&b);
  }
  inline void Swap(HashValueGL* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashValueGL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HashValueGL* New() const final {
    return CreateMaybeMessage<HashValueGL>(nullptr);
  }

  HashValueGL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HashValueGL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HashValueGL& from);
  void MergeFrom(const HashValueGL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HashValueGL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.HashValueGL";
  }
  protected:
  explicit HashValueGL(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .hashdb.v1.Fea hash = 1;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const ::hashdb::v1::Fea& hash() const;
  ::hashdb::v1::Fea* release_hash();
  ::hashdb::v1::Fea* mutable_hash();
  void set_allocated_hash(::hashdb::v1::Fea* hash);
  private:
  const ::hashdb::v1::Fea& _internal_hash() const;
  ::hashdb::v1::Fea* _internal_mutable_hash();
  public:
  void unsafe_arena_set_allocated_hash(
      ::hashdb::v1::Fea* hash);
  ::hashdb::v1::Fea* unsafe_arena_release_hash();

  // .hashdb.v1.Fea12 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::hashdb::v1::Fea12& value() const;
  ::hashdb::v1::Fea12* release_value();
  ::hashdb::v1::Fea12* mutable_value();
  void set_allocated_value(::hashdb::v1::Fea12* value);
  private:
  const ::hashdb::v1::Fea12& _internal_value() const;
  ::hashdb::v1::Fea12* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::hashdb::v1::Fea12* value);
  ::hashdb::v1::Fea12* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:hashdb.v1.HashValueGL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::hashdb::v1::Fea* hash_;
  ::hashdb::v1::Fea12* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class KeyValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.KeyValue) */ {
 public:
  inline KeyValue() : KeyValue(nullptr) {};
  virtual ~KeyValue();

  KeyValue(const KeyValue& from);
  KeyValue(KeyValue&& from) noexcept
    : KeyValue() {
    *this = ::std::move(from);
  }

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValue& operator=(KeyValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeyValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
               &_KeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(KeyValue& a, KeyValue& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyValue* New() const final {
    return CreateMaybeMessage<KeyValue>(nullptr);
  }

  KeyValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.KeyValue";
  }
  protected:
  explicit KeyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kKeyFieldNumber = 1,
  };
  // string value = 2;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .hashdb.v1.Fea key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // @@protoc_insertion_point(class_scope:hashdb.v1.KeyValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::hashdb::v1::Fea* key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class FeList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.FeList) */ {
 public:
  inline FeList() : FeList(nullptr) {};
  virtual ~FeList();

  FeList(const FeList& from);
  FeList(FeList&& from) noexcept
    : FeList() {
    *this = ::std::move(from);
  }

  inline FeList& operator=(const FeList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeList& operator=(FeList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeList* internal_default_instance() {
    return reinterpret_cast<const FeList*>(
               &_FeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(FeList& a, FeList& b) {
    a.Swap(&b);
  }
  inline void Swap(FeList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeList* New() const final {
    return CreateMaybeMessage<FeList>(nullptr);
  }

  FeList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeList& from);
  void MergeFrom(const FeList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.FeList";
  }
  protected:
  explicit FeList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeFieldNumber = 1,
  };
  // repeated uint64 fe = 1;
  int fe_size() const;
  private:
  int _internal_fe_size() const;
  public:
  void clear_fe();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fe(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_fe() const;
  void _internal_add_fe(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_fe();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 fe(int index) const;
  void set_fe(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_fe(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      fe() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_fe();

  // @@protoc_insertion_point(class_scope:hashdb.v1.FeList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > fe_;
  mutable std::atomic<int> _fe_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SiblingList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SiblingList) */ {
 public:
  inline SiblingList() : SiblingList(nullptr) {};
  virtual ~SiblingList();

  SiblingList(const SiblingList& from);
  SiblingList(SiblingList&& from) noexcept
    : SiblingList() {
    *this = ::std::move(from);
  }

  inline SiblingList& operator=(const SiblingList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SiblingList& operator=(SiblingList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SiblingList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SiblingList* internal_default_instance() {
    return reinterpret_cast<const SiblingList*>(
               &_SiblingList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SiblingList& a, SiblingList& b) {
    a.Swap(&b);
  }
  inline void Swap(SiblingList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SiblingList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SiblingList* New() const final {
    return CreateMaybeMessage<SiblingList>(nullptr);
  }

  SiblingList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SiblingList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SiblingList& from);
  void MergeFrom(const SiblingList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SiblingList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SiblingList";
  }
  protected:
  explicit SiblingList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSiblingFieldNumber = 1,
  };
  // repeated uint64 sibling = 1;
  int sibling_size() const;
  private:
  int _internal_sibling_size() const;
  public:
  void clear_sibling();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sibling(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_sibling() const;
  void _internal_add_sibling(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_sibling();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 sibling(int index) const;
  void set_sibling(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_sibling(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      sibling() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_sibling();

  // @@protoc_insertion_point(class_scope:hashdb.v1.SiblingList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > sibling_;
  mutable std::atomic<int> _sibling_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class ResultCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.ResultCode) */ {
 public:
  inline ResultCode() : ResultCode(nullptr) {};
  virtual ~ResultCode();

  ResultCode(const ResultCode& from);
  ResultCode(ResultCode&& from) noexcept
    : ResultCode() {
    *this = ::std::move(from);
  }

  inline ResultCode& operator=(const ResultCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultCode& operator=(ResultCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResultCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResultCode* internal_default_instance() {
    return reinterpret_cast<const ResultCode*>(
               &_ResultCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ResultCode& a, ResultCode& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResultCode* New() const final {
    return CreateMaybeMessage<ResultCode>(nullptr);
  }

  ResultCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResultCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResultCode& from);
  void MergeFrom(const ResultCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.ResultCode";
  }
  protected:
  explicit ResultCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hashdb_2eproto);
    return ::descriptor_table_hashdb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ResultCode_Code Code;
  static constexpr Code CODE_UNSPECIFIED =
    ResultCode_Code_CODE_UNSPECIFIED;
  static constexpr Code CODE_SUCCESS =
    ResultCode_Code_CODE_SUCCESS;
  static constexpr Code CODE_DB_KEY_NOT_FOUND =
    ResultCode_Code_CODE_DB_KEY_NOT_FOUND;
  static constexpr Code CODE_DB_ERROR =
    ResultCode_Code_CODE_DB_ERROR;
  static constexpr Code CODE_INTERNAL_ERROR =
    ResultCode_Code_CODE_INTERNAL_ERROR;
  static constexpr Code CODE_SMT_INVALID_DATA_SIZE =
    ResultCode_Code_CODE_SMT_INVALID_DATA_SIZE;
  static inline bool Code_IsValid(int value) {
    return ResultCode_Code_IsValid(value);
  }
  static constexpr Code Code_MIN =
    ResultCode_Code_Code_MIN;
  static constexpr Code Code_MAX =
    ResultCode_Code_Code_MAX;
  static constexpr int Code_ARRAYSIZE =
    ResultCode_Code_Code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Code_descriptor() {
    return ResultCode_Code_descriptor();
  }
  template<typename T>
  static inline const std::string& Code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Code_Name.");
    return ResultCode_Code_Name(enum_t_value);
  }
  static inline bool Code_Parse(const std::string& name,
      Code* value) {
    return ResultCode_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // .hashdb.v1.ResultCode.Code code = 1;
  void clear_code();
  ::hashdb::v1::ResultCode_Code code() const;
  void set_code(::hashdb::v1::ResultCode_Code value);
  private:
  ::hashdb::v1::ResultCode_Code _internal_code() const;
  void _internal_set_code(::hashdb::v1::ResultCode_Code value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.ResultCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hashdb_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Version

// string v0_0_1 = 1;
inline void Version::clear_v0_0_1() {
  v0_0_1_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Version::v0_0_1() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Version.v0_0_1)
  return _internal_v0_0_1();
}
inline void Version::set_v0_0_1(const std::string& value) {
  _internal_set_v0_0_1(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Version.v0_0_1)
}
inline std::string* Version::mutable_v0_0_1() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.Version.v0_0_1)
  return _internal_mutable_v0_0_1();
}
inline const std::string& Version::_internal_v0_0_1() const {
  return v0_0_1_.Get();
}
inline void Version::_internal_set_v0_0_1(const std::string& value) {
  
  v0_0_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Version::set_v0_0_1(std::string&& value) {
  
  v0_0_1_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.Version.v0_0_1)
}
inline void Version::set_v0_0_1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  v0_0_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.Version.v0_0_1)
}
inline void Version::set_v0_0_1(const char* value,
    size_t size) {
  
  v0_0_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.Version.v0_0_1)
}
inline std::string* Version::_internal_mutable_v0_0_1() {
  
  return v0_0_1_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Version::release_v0_0_1() {
  // @@protoc_insertion_point(field_release:hashdb.v1.Version.v0_0_1)
  return v0_0_1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Version::set_allocated_v0_0_1(std::string* v0_0_1) {
  if (v0_0_1 != nullptr) {
    
  } else {
    
  }
  v0_0_1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), v0_0_1,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.Version.v0_0_1)
}
inline std::string* Version::unsafe_arena_release_v0_0_1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.Version.v0_0_1)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return v0_0_1_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Version::unsafe_arena_set_allocated_v0_0_1(
    std::string* v0_0_1) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (v0_0_1 != nullptr) {
    
  } else {
    
  }
  v0_0_1_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      v0_0_1, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.Version.v0_0_1)
}

// -------------------------------------------------------------------

// SetRequest

// .hashdb.v1.Fea old_root = 1;
inline bool SetRequest::_internal_has_old_root() const {
  return this != internal_default_instance() && old_root_ != nullptr;
}
inline bool SetRequest::has_old_root() const {
  return _internal_has_old_root();
}
inline void SetRequest::clear_old_root() {
  if (GetArena() == nullptr && old_root_ != nullptr) {
    delete old_root_;
  }
  old_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetRequest::_internal_old_root() const {
  const ::hashdb::v1::Fea* p = old_root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetRequest::old_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.old_root)
  return _internal_old_root();
}
inline void SetRequest::unsafe_arena_set_allocated_old_root(
    ::hashdb::v1::Fea* old_root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_root_);
  }
  old_root_ = old_root;
  if (old_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetRequest.old_root)
}
inline ::hashdb::v1::Fea* SetRequest::release_old_root() {
  auto temp = unsafe_arena_release_old_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::unsafe_arena_release_old_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.old_root)
  
  ::hashdb::v1::Fea* temp = old_root_;
  old_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::_internal_mutable_old_root() {
  
  if (old_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    old_root_ = p;
  }
  return old_root_;
}
inline ::hashdb::v1::Fea* SetRequest::mutable_old_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.old_root)
  return _internal_mutable_old_root();
}
inline void SetRequest::set_allocated_old_root(::hashdb::v1::Fea* old_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete old_root_;
  }
  if (old_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(old_root);
    if (message_arena != submessage_arena) {
      old_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_root, submessage_arena);
    }
    
  } else {
    
  }
  old_root_ = old_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.old_root)
}

// .hashdb.v1.Fea key = 2;
inline bool SetRequest::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool SetRequest::has_key() const {
  return _internal_has_key();
}
inline void SetRequest::clear_key() {
  if (GetArena() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.key)
  return _internal_key();
}
inline void SetRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetRequest.key)
}
inline ::hashdb::v1::Fea* SetRequest::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.key)
  
  ::hashdb::v1::Fea* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::hashdb::v1::Fea* SetRequest::mutable_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.key)
  return _internal_mutable_key();
}
inline void SetRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.key)
}

// string value = 3;
inline void SetRequest::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetRequest::value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.value)
  return _internal_value();
}
inline void SetRequest::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.value)
}
inline std::string* SetRequest::mutable_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.value)
  return _internal_mutable_value();
}
inline const std::string& SetRequest::_internal_value() const {
  return value_.Get();
}
inline void SetRequest::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetRequest::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetRequest.value)
}
inline void SetRequest::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetRequest.value)
}
inline void SetRequest::set_value(const char* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetRequest.value)
}
inline std::string* SetRequest::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetRequest::release_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.value)
}
inline std::string* SetRequest::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetRequest.value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetRequest::unsafe_arena_set_allocated_value(
    std::string* value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (value != nullptr) {
    
  } else {
    
  }
  value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetRequest.value)
}

// .hashdb.v1.Persistence persistence = 4;
inline void SetRequest::clear_persistence() {
  persistence_ = 0;
}
inline ::hashdb::v1::Persistence SetRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(persistence_);
}
inline ::hashdb::v1::Persistence SetRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.persistence)
  return _internal_persistence();
}
inline void SetRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  persistence_ = value;
}
inline void SetRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.persistence)
}

// bool details = 5;
inline void SetRequest::clear_details() {
  details_ = false;
}
inline bool SetRequest::_internal_details() const {
  return details_;
}
inline bool SetRequest::details() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.details)
  return _internal_details();
}
inline void SetRequest::_internal_set_details(bool value) {
  
  details_ = value;
}
inline void SetRequest::set_details(bool value) {
  _internal_set_details(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.details)
}

// bool get_db_read_log = 6;
inline void SetRequest::clear_get_db_read_log() {
  get_db_read_log_ = false;
}
inline bool SetRequest::_internal_get_db_read_log() const {
  return get_db_read_log_;
}
inline bool SetRequest::get_db_read_log() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.get_db_read_log)
  return _internal_get_db_read_log();
}
inline void SetRequest::_internal_set_get_db_read_log(bool value) {
  
  get_db_read_log_ = value;
}
inline void SetRequest::set_get_db_read_log(bool value) {
  _internal_set_get_db_read_log(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.get_db_read_log)
}

// string batch_uuid = 7;
inline void SetRequest::clear_batch_uuid() {
  batch_uuid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.batch_uuid)
  return _internal_batch_uuid();
}
inline void SetRequest::set_batch_uuid(const std::string& value) {
  _internal_set_batch_uuid(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.batch_uuid)
}
inline std::string* SetRequest::mutable_batch_uuid() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.batch_uuid)
  return _internal_mutable_batch_uuid();
}
inline const std::string& SetRequest::_internal_batch_uuid() const {
  return batch_uuid_.Get();
}
inline void SetRequest::_internal_set_batch_uuid(const std::string& value) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetRequest::set_batch_uuid(std::string&& value) {
  
  batch_uuid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetRequest.batch_uuid)
}
inline void SetRequest::set_batch_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetRequest.batch_uuid)
}
inline void SetRequest::set_batch_uuid(const char* value,
    size_t size) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetRequest.batch_uuid)
}
inline std::string* SetRequest::_internal_mutable_batch_uuid() {
  
  return batch_uuid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.batch_uuid)
  return batch_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), batch_uuid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.batch_uuid)
}
inline std::string* SetRequest::unsafe_arena_release_batch_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetRequest.batch_uuid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return batch_uuid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetRequest::unsafe_arena_set_allocated_batch_uuid(
    std::string* batch_uuid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      batch_uuid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetRequest.batch_uuid)
}

// uint64 tx = 8;
inline void SetRequest::clear_tx() {
  tx_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetRequest::_internal_tx() const {
  return tx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetRequest::tx() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.tx)
  return _internal_tx();
}
inline void SetRequest::_internal_set_tx(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  tx_ = value;
}
inline void SetRequest::set_tx(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_tx(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.tx)
}

// -------------------------------------------------------------------

// GetRequest

// .hashdb.v1.Fea root = 1;
inline bool GetRequest::_internal_has_root() const {
  return this != internal_default_instance() && root_ != nullptr;
}
inline bool GetRequest::has_root() const {
  return _internal_has_root();
}
inline void GetRequest::clear_root() {
  if (GetArena() == nullptr && root_ != nullptr) {
    delete root_;
  }
  root_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetRequest::_internal_root() const {
  const ::hashdb::v1::Fea* p = root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetRequest::root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.root)
  return _internal_root();
}
inline void GetRequest::unsafe_arena_set_allocated_root(
    ::hashdb::v1::Fea* root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(root_);
  }
  root_ = root;
  if (root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetRequest.root)
}
inline ::hashdb::v1::Fea* GetRequest::release_root() {
  auto temp = unsafe_arena_release_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetRequest.root)
  
  ::hashdb::v1::Fea* temp = root_;
  root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::_internal_mutable_root() {
  
  if (root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    root_ = p;
  }
  return root_;
}
inline ::hashdb::v1::Fea* GetRequest::mutable_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetRequest.root)
  return _internal_mutable_root();
}
inline void GetRequest::set_allocated_root(::hashdb::v1::Fea* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete root_;
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(root);
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    
  } else {
    
  }
  root_ = root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetRequest.root)
}

// .hashdb.v1.Fea key = 2;
inline bool GetRequest::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool GetRequest::has_key() const {
  return _internal_has_key();
}
inline void GetRequest::clear_key() {
  if (GetArena() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.key)
  return _internal_key();
}
inline void GetRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetRequest.key)
}
inline ::hashdb::v1::Fea* GetRequest::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetRequest.key)
  
  ::hashdb::v1::Fea* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::hashdb::v1::Fea* GetRequest::mutable_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetRequest.key)
  return _internal_mutable_key();
}
inline void GetRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetRequest.key)
}

// bool details = 3;
inline void GetRequest::clear_details() {
  details_ = false;
}
inline bool GetRequest::_internal_details() const {
  return details_;
}
inline bool GetRequest::details() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.details)
  return _internal_details();
}
inline void GetRequest::_internal_set_details(bool value) {
  
  details_ = value;
}
inline void GetRequest::set_details(bool value) {
  _internal_set_details(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetRequest.details)
}

// bool get_db_read_log = 4;
inline void GetRequest::clear_get_db_read_log() {
  get_db_read_log_ = false;
}
inline bool GetRequest::_internal_get_db_read_log() const {
  return get_db_read_log_;
}
inline bool GetRequest::get_db_read_log() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.get_db_read_log)
  return _internal_get_db_read_log();
}
inline void GetRequest::_internal_set_get_db_read_log(bool value) {
  
  get_db_read_log_ = value;
}
inline void GetRequest::set_get_db_read_log(bool value) {
  _internal_set_get_db_read_log(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetRequest.get_db_read_log)
}

// string batch_uuid = 5;
inline void GetRequest::clear_batch_uuid() {
  batch_uuid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.batch_uuid)
  return _internal_batch_uuid();
}
inline void GetRequest::set_batch_uuid(const std::string& value) {
  _internal_set_batch_uuid(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetRequest.batch_uuid)
}
inline std::string* GetRequest::mutable_batch_uuid() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetRequest.batch_uuid)
  return _internal_mutable_batch_uuid();
}
inline const std::string& GetRequest::_internal_batch_uuid() const {
  return batch_uuid_.Get();
}
inline void GetRequest::_internal_set_batch_uuid(const std::string& value) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetRequest::set_batch_uuid(std::string&& value) {
  
  batch_uuid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.GetRequest.batch_uuid)
}
inline void GetRequest::set_batch_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.GetRequest.batch_uuid)
}
inline void GetRequest::set_batch_uuid(const char* value,
    size_t size) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.GetRequest.batch_uuid)
}
inline std::string* GetRequest::_internal_mutable_batch_uuid() {
  
  return batch_uuid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetRequest.batch_uuid)
  return batch_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), batch_uuid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetRequest.batch_uuid)
}
inline std::string* GetRequest::unsafe_arena_release_batch_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.GetRequest.batch_uuid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return batch_uuid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetRequest::unsafe_arena_set_allocated_batch_uuid(
    std::string* batch_uuid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      batch_uuid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetRequest.batch_uuid)
}

// -------------------------------------------------------------------

// SetProgramRequest

// .hashdb.v1.Fea key = 1;
inline bool SetProgramRequest::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool SetProgramRequest::has_key() const {
  return _internal_has_key();
}
inline void SetProgramRequest::clear_key() {
  if (GetArena() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetProgramRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetProgramRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.key)
  return _internal_key();
}
inline void SetProgramRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetProgramRequest.key)
}
inline ::hashdb::v1::Fea* SetProgramRequest::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetProgramRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetProgramRequest.key)
  
  ::hashdb::v1::Fea* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetProgramRequest::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::hashdb::v1::Fea* SetProgramRequest::mutable_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetProgramRequest.key)
  return _internal_mutable_key();
}
inline void SetProgramRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetProgramRequest.key)
}

// bytes data = 2;
inline void SetProgramRequest::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetProgramRequest::data() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.data)
  return _internal_data();
}
inline void SetProgramRequest::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetProgramRequest.data)
}
inline std::string* SetProgramRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetProgramRequest.data)
  return _internal_mutable_data();
}
inline const std::string& SetProgramRequest::_internal_data() const {
  return data_.Get();
}
inline void SetProgramRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetProgramRequest::set_data(std::string&& value) {
  
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetProgramRequest.data)
}
inline void SetProgramRequest::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetProgramRequest.data)
}
inline void SetProgramRequest::set_data(const void* value,
    size_t size) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetProgramRequest.data)
}
inline std::string* SetProgramRequest::_internal_mutable_data() {
  
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetProgramRequest::release_data() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetProgramRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetProgramRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetProgramRequest.data)
}
inline std::string* SetProgramRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetProgramRequest.data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetProgramRequest::unsafe_arena_set_allocated_data(
    std::string* data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data != nullptr) {
    
  } else {
    
  }
  data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetProgramRequest.data)
}

// bool persistent = 3;
inline void SetProgramRequest::clear_persistent() {
  persistent_ = false;
}
inline bool SetProgramRequest::_internal_persistent() const {
  return persistent_;
}
inline bool SetProgramRequest::persistent() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.persistent)
  return _internal_persistent();
}
inline void SetProgramRequest::_internal_set_persistent(bool value) {
  
  persistent_ = value;
}
inline void SetProgramRequest::set_persistent(bool value) {
  _internal_set_persistent(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetProgramRequest.persistent)
}

// -------------------------------------------------------------------

// GetProgramRequest

// .hashdb.v1.Fea key = 1;
inline bool GetProgramRequest::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool GetProgramRequest::has_key() const {
  return _internal_has_key();
}
inline void GetProgramRequest::clear_key() {
  if (GetArena() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetProgramRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetProgramRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetProgramRequest.key)
  return _internal_key();
}
inline void GetProgramRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetProgramRequest.key)
}
inline ::hashdb::v1::Fea* GetProgramRequest::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* GetProgramRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetProgramRequest.key)
  
  ::hashdb::v1::Fea* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetProgramRequest::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::hashdb::v1::Fea* GetProgramRequest::mutable_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetProgramRequest.key)
  return _internal_mutable_key();
}
inline void GetProgramRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetProgramRequest.key)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoadDBRequest

// map<string, .hashdb.v1.FeList> input_db = 1;
inline int LoadDBRequest::_internal_input_db_size() const {
  return input_db_.size();
}
inline int LoadDBRequest::input_db_size() const {
  return _internal_input_db_size();
}
inline void LoadDBRequest::clear_input_db() {
  input_db_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
LoadDBRequest::_internal_input_db() const {
  return input_db_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
LoadDBRequest::input_db() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.LoadDBRequest.input_db)
  return _internal_input_db();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
LoadDBRequest::_internal_mutable_input_db() {
  return input_db_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
LoadDBRequest::mutable_input_db() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.LoadDBRequest.input_db)
  return _internal_mutable_input_db();
}

// bool persistent = 2;
inline void LoadDBRequest::clear_persistent() {
  persistent_ = false;
}
inline bool LoadDBRequest::_internal_persistent() const {
  return persistent_;
}
inline bool LoadDBRequest::persistent() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.LoadDBRequest.persistent)
  return _internal_persistent();
}
inline void LoadDBRequest::_internal_set_persistent(bool value) {
  
  persistent_ = value;
}
inline void LoadDBRequest::set_persistent(bool value) {
  _internal_set_persistent(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.LoadDBRequest.persistent)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoadProgramDBRequest

// map<string, bytes> input_program_db = 1;
inline int LoadProgramDBRequest::_internal_input_program_db_size() const {
  return input_program_db_.size();
}
inline int LoadProgramDBRequest::input_program_db_size() const {
  return _internal_input_program_db_size();
}
inline void LoadProgramDBRequest::clear_input_program_db() {
  input_program_db_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LoadProgramDBRequest::_internal_input_program_db() const {
  return input_program_db_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LoadProgramDBRequest::input_program_db() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.LoadProgramDBRequest.input_program_db)
  return _internal_input_program_db();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LoadProgramDBRequest::_internal_mutable_input_program_db() {
  return input_program_db_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LoadProgramDBRequest::mutable_input_program_db() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.LoadProgramDBRequest.input_program_db)
  return _internal_mutable_input_program_db();
}

// bool persistent = 2;
inline void LoadProgramDBRequest::clear_persistent() {
  persistent_ = false;
}
inline bool LoadProgramDBRequest::_internal_persistent() const {
  return persistent_;
}
inline bool LoadProgramDBRequest::persistent() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.LoadProgramDBRequest.persistent)
  return _internal_persistent();
}
inline void LoadProgramDBRequest::_internal_set_persistent(bool value) {
  
  persistent_ = value;
}
inline void LoadProgramDBRequest::set_persistent(bool value) {
  _internal_set_persistent(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.LoadProgramDBRequest.persistent)
}

// -------------------------------------------------------------------

// FlushRequest

// string batch_uuid = 1;
inline void FlushRequest::clear_batch_uuid() {
  batch_uuid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FlushRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushRequest.batch_uuid)
  return _internal_batch_uuid();
}
inline void FlushRequest::set_batch_uuid(const std::string& value) {
  _internal_set_batch_uuid(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushRequest.batch_uuid)
}
inline std::string* FlushRequest::mutable_batch_uuid() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FlushRequest.batch_uuid)
  return _internal_mutable_batch_uuid();
}
inline const std::string& FlushRequest::_internal_batch_uuid() const {
  return batch_uuid_.Get();
}
inline void FlushRequest::_internal_set_batch_uuid(const std::string& value) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FlushRequest::set_batch_uuid(std::string&& value) {
  
  batch_uuid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.FlushRequest.batch_uuid)
}
inline void FlushRequest::set_batch_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.FlushRequest.batch_uuid)
}
inline void FlushRequest::set_batch_uuid(const char* value,
    size_t size) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.FlushRequest.batch_uuid)
}
inline std::string* FlushRequest::_internal_mutable_batch_uuid() {
  
  return batch_uuid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FlushRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FlushRequest.batch_uuid)
  return batch_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FlushRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), batch_uuid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FlushRequest.batch_uuid)
}
inline std::string* FlushRequest::unsafe_arena_release_batch_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.FlushRequest.batch_uuid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return batch_uuid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void FlushRequest::unsafe_arena_set_allocated_batch_uuid(
    std::string* batch_uuid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      batch_uuid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.FlushRequest.batch_uuid)
}

// string new_state_root = 2;
inline void FlushRequest::clear_new_state_root() {
  new_state_root_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FlushRequest::new_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushRequest.new_state_root)
  return _internal_new_state_root();
}
inline void FlushRequest::set_new_state_root(const std::string& value) {
  _internal_set_new_state_root(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushRequest.new_state_root)
}
inline std::string* FlushRequest::mutable_new_state_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FlushRequest.new_state_root)
  return _internal_mutable_new_state_root();
}
inline const std::string& FlushRequest::_internal_new_state_root() const {
  return new_state_root_.Get();
}
inline void FlushRequest::_internal_set_new_state_root(const std::string& value) {
  
  new_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FlushRequest::set_new_state_root(std::string&& value) {
  
  new_state_root_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.FlushRequest.new_state_root)
}
inline void FlushRequest::set_new_state_root(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  new_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.FlushRequest.new_state_root)
}
inline void FlushRequest::set_new_state_root(const char* value,
    size_t size) {
  
  new_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.FlushRequest.new_state_root)
}
inline std::string* FlushRequest::_internal_mutable_new_state_root() {
  
  return new_state_root_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FlushRequest::release_new_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FlushRequest.new_state_root)
  return new_state_root_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FlushRequest::set_allocated_new_state_root(std::string* new_state_root) {
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  new_state_root_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_state_root,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FlushRequest.new_state_root)
}
inline std::string* FlushRequest::unsafe_arena_release_new_state_root() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.FlushRequest.new_state_root)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return new_state_root_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void FlushRequest::unsafe_arena_set_allocated_new_state_root(
    std::string* new_state_root) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  new_state_root_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      new_state_root, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.FlushRequest.new_state_root)
}

// .hashdb.v1.Persistence persistence = 3;
inline void FlushRequest::clear_persistence() {
  persistence_ = 0;
}
inline ::hashdb::v1::Persistence FlushRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(persistence_);
}
inline ::hashdb::v1::Persistence FlushRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushRequest.persistence)
  return _internal_persistence();
}
inline void FlushRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  persistence_ = value;
}
inline void FlushRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushRequest.persistence)
}

// -------------------------------------------------------------------

// SemiFlushRequest

// string batch_uuid = 1;
inline void SemiFlushRequest::clear_batch_uuid() {
  batch_uuid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SemiFlushRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SemiFlushRequest.batch_uuid)
  return _internal_batch_uuid();
}
inline void SemiFlushRequest::set_batch_uuid(const std::string& value) {
  _internal_set_batch_uuid(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SemiFlushRequest.batch_uuid)
}
inline std::string* SemiFlushRequest::mutable_batch_uuid() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SemiFlushRequest.batch_uuid)
  return _internal_mutable_batch_uuid();
}
inline const std::string& SemiFlushRequest::_internal_batch_uuid() const {
  return batch_uuid_.Get();
}
inline void SemiFlushRequest::_internal_set_batch_uuid(const std::string& value) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SemiFlushRequest::set_batch_uuid(std::string&& value) {
  
  batch_uuid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SemiFlushRequest.batch_uuid)
}
inline void SemiFlushRequest::set_batch_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SemiFlushRequest.batch_uuid)
}
inline void SemiFlushRequest::set_batch_uuid(const char* value,
    size_t size) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SemiFlushRequest.batch_uuid)
}
inline std::string* SemiFlushRequest::_internal_mutable_batch_uuid() {
  
  return batch_uuid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SemiFlushRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SemiFlushRequest.batch_uuid)
  return batch_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SemiFlushRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), batch_uuid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SemiFlushRequest.batch_uuid)
}
inline std::string* SemiFlushRequest::unsafe_arena_release_batch_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SemiFlushRequest.batch_uuid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return batch_uuid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SemiFlushRequest::unsafe_arena_set_allocated_batch_uuid(
    std::string* batch_uuid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      batch_uuid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SemiFlushRequest.batch_uuid)
}

// string new_state_root = 2;
inline void SemiFlushRequest::clear_new_state_root() {
  new_state_root_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SemiFlushRequest::new_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SemiFlushRequest.new_state_root)
  return _internal_new_state_root();
}
inline void SemiFlushRequest::set_new_state_root(const std::string& value) {
  _internal_set_new_state_root(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SemiFlushRequest.new_state_root)
}
inline std::string* SemiFlushRequest::mutable_new_state_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SemiFlushRequest.new_state_root)
  return _internal_mutable_new_state_root();
}
inline const std::string& SemiFlushRequest::_internal_new_state_root() const {
  return new_state_root_.Get();
}
inline void SemiFlushRequest::_internal_set_new_state_root(const std::string& value) {
  
  new_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SemiFlushRequest::set_new_state_root(std::string&& value) {
  
  new_state_root_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SemiFlushRequest.new_state_root)
}
inline void SemiFlushRequest::set_new_state_root(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  new_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SemiFlushRequest.new_state_root)
}
inline void SemiFlushRequest::set_new_state_root(const char* value,
    size_t size) {
  
  new_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SemiFlushRequest.new_state_root)
}
inline std::string* SemiFlushRequest::_internal_mutable_new_state_root() {
  
  return new_state_root_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SemiFlushRequest::release_new_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SemiFlushRequest.new_state_root)
  return new_state_root_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SemiFlushRequest::set_allocated_new_state_root(std::string* new_state_root) {
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  new_state_root_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_state_root,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SemiFlushRequest.new_state_root)
}
inline std::string* SemiFlushRequest::unsafe_arena_release_new_state_root() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SemiFlushRequest.new_state_root)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return new_state_root_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SemiFlushRequest::unsafe_arena_set_allocated_new_state_root(
    std::string* new_state_root) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  new_state_root_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      new_state_root, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SemiFlushRequest.new_state_root)
}

// .hashdb.v1.Persistence persistence = 3;
inline void SemiFlushRequest::clear_persistence() {
  persistence_ = 0;
}
inline ::hashdb::v1::Persistence SemiFlushRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(persistence_);
}
inline ::hashdb::v1::Persistence SemiFlushRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SemiFlushRequest.persistence)
  return _internal_persistence();
}
inline void SemiFlushRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  persistence_ = value;
}
inline void SemiFlushRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SemiFlushRequest.persistence)
}

// -------------------------------------------------------------------

// GetFlushDataRequest

// uint64 flush_id = 1;
inline void GetFlushDataRequest::clear_flush_id() {
  flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushDataRequest::_internal_flush_id() const {
  return flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushDataRequest::flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataRequest.flush_id)
  return _internal_flush_id();
}
inline void GetFlushDataRequest::_internal_set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  flush_id_ = value;
}
inline void GetFlushDataRequest::set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushDataRequest.flush_id)
}

// -------------------------------------------------------------------

// ConsolidateStateRequest

// .hashdb.v1.Fea virtual_state_root = 1;
inline bool ConsolidateStateRequest::_internal_has_virtual_state_root() const {
  return this != internal_default_instance() && virtual_state_root_ != nullptr;
}
inline bool ConsolidateStateRequest::has_virtual_state_root() const {
  return _internal_has_virtual_state_root();
}
inline void ConsolidateStateRequest::clear_virtual_state_root() {
  if (GetArena() == nullptr && virtual_state_root_ != nullptr) {
    delete virtual_state_root_;
  }
  virtual_state_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& ConsolidateStateRequest::_internal_virtual_state_root() const {
  const ::hashdb::v1::Fea* p = virtual_state_root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& ConsolidateStateRequest::virtual_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ConsolidateStateRequest.virtual_state_root)
  return _internal_virtual_state_root();
}
inline void ConsolidateStateRequest::unsafe_arena_set_allocated_virtual_state_root(
    ::hashdb::v1::Fea* virtual_state_root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtual_state_root_);
  }
  virtual_state_root_ = virtual_state_root;
  if (virtual_state_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.ConsolidateStateRequest.virtual_state_root)
}
inline ::hashdb::v1::Fea* ConsolidateStateRequest::release_virtual_state_root() {
  auto temp = unsafe_arena_release_virtual_state_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* ConsolidateStateRequest::unsafe_arena_release_virtual_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.ConsolidateStateRequest.virtual_state_root)
  
  ::hashdb::v1::Fea* temp = virtual_state_root_;
  virtual_state_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* ConsolidateStateRequest::_internal_mutable_virtual_state_root() {
  
  if (virtual_state_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    virtual_state_root_ = p;
  }
  return virtual_state_root_;
}
inline ::hashdb::v1::Fea* ConsolidateStateRequest::mutable_virtual_state_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ConsolidateStateRequest.virtual_state_root)
  return _internal_mutable_virtual_state_root();
}
inline void ConsolidateStateRequest::set_allocated_virtual_state_root(::hashdb::v1::Fea* virtual_state_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete virtual_state_root_;
  }
  if (virtual_state_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(virtual_state_root);
    if (message_arena != submessage_arena) {
      virtual_state_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtual_state_root, submessage_arena);
    }
    
  } else {
    
  }
  virtual_state_root_ = virtual_state_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.ConsolidateStateRequest.virtual_state_root)
}

// .hashdb.v1.Persistence persistence = 2;
inline void ConsolidateStateRequest::clear_persistence() {
  persistence_ = 0;
}
inline ::hashdb::v1::Persistence ConsolidateStateRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(persistence_);
}
inline ::hashdb::v1::Persistence ConsolidateStateRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ConsolidateStateRequest.persistence)
  return _internal_persistence();
}
inline void ConsolidateStateRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  persistence_ = value;
}
inline void ConsolidateStateRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.ConsolidateStateRequest.persistence)
}

// -------------------------------------------------------------------

// PurgeRequest

// string batch_uuid = 1;
inline void PurgeRequest::clear_batch_uuid() {
  batch_uuid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PurgeRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.PurgeRequest.batch_uuid)
  return _internal_batch_uuid();
}
inline void PurgeRequest::set_batch_uuid(const std::string& value) {
  _internal_set_batch_uuid(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.PurgeRequest.batch_uuid)
}
inline std::string* PurgeRequest::mutable_batch_uuid() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.PurgeRequest.batch_uuid)
  return _internal_mutable_batch_uuid();
}
inline const std::string& PurgeRequest::_internal_batch_uuid() const {
  return batch_uuid_.Get();
}
inline void PurgeRequest::_internal_set_batch_uuid(const std::string& value) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PurgeRequest::set_batch_uuid(std::string&& value) {
  
  batch_uuid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.PurgeRequest.batch_uuid)
}
inline void PurgeRequest::set_batch_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.PurgeRequest.batch_uuid)
}
inline void PurgeRequest::set_batch_uuid(const char* value,
    size_t size) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.PurgeRequest.batch_uuid)
}
inline std::string* PurgeRequest::_internal_mutable_batch_uuid() {
  
  return batch_uuid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PurgeRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.PurgeRequest.batch_uuid)
  return batch_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PurgeRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), batch_uuid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.PurgeRequest.batch_uuid)
}
inline std::string* PurgeRequest::unsafe_arena_release_batch_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.PurgeRequest.batch_uuid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return batch_uuid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PurgeRequest::unsafe_arena_set_allocated_batch_uuid(
    std::string* batch_uuid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      batch_uuid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.PurgeRequest.batch_uuid)
}

// .hashdb.v1.Fea new_state_root = 2;
inline bool PurgeRequest::_internal_has_new_state_root() const {
  return this != internal_default_instance() && new_state_root_ != nullptr;
}
inline bool PurgeRequest::has_new_state_root() const {
  return _internal_has_new_state_root();
}
inline void PurgeRequest::clear_new_state_root() {
  if (GetArena() == nullptr && new_state_root_ != nullptr) {
    delete new_state_root_;
  }
  new_state_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& PurgeRequest::_internal_new_state_root() const {
  const ::hashdb::v1::Fea* p = new_state_root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& PurgeRequest::new_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.PurgeRequest.new_state_root)
  return _internal_new_state_root();
}
inline void PurgeRequest::unsafe_arena_set_allocated_new_state_root(
    ::hashdb::v1::Fea* new_state_root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_state_root_);
  }
  new_state_root_ = new_state_root;
  if (new_state_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.PurgeRequest.new_state_root)
}
inline ::hashdb::v1::Fea* PurgeRequest::release_new_state_root() {
  auto temp = unsafe_arena_release_new_state_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* PurgeRequest::unsafe_arena_release_new_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.PurgeRequest.new_state_root)
  
  ::hashdb::v1::Fea* temp = new_state_root_;
  new_state_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* PurgeRequest::_internal_mutable_new_state_root() {
  
  if (new_state_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    new_state_root_ = p;
  }
  return new_state_root_;
}
inline ::hashdb::v1::Fea* PurgeRequest::mutable_new_state_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.PurgeRequest.new_state_root)
  return _internal_mutable_new_state_root();
}
inline void PurgeRequest::set_allocated_new_state_root(::hashdb::v1::Fea* new_state_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete new_state_root_;
  }
  if (new_state_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(new_state_root);
    if (message_arena != submessage_arena) {
      new_state_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_state_root, submessage_arena);
    }
    
  } else {
    
  }
  new_state_root_ = new_state_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.PurgeRequest.new_state_root)
}

// .hashdb.v1.Persistence persistence = 3;
inline void PurgeRequest::clear_persistence() {
  persistence_ = 0;
}
inline ::hashdb::v1::Persistence PurgeRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(persistence_);
}
inline ::hashdb::v1::Persistence PurgeRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.PurgeRequest.persistence)
  return _internal_persistence();
}
inline void PurgeRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  persistence_ = value;
}
inline void PurgeRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.PurgeRequest.persistence)
}

// -------------------------------------------------------------------

// ReadTreeRequest

// .hashdb.v1.Fea state_root = 1;
inline bool ReadTreeRequest::_internal_has_state_root() const {
  return this != internal_default_instance() && state_root_ != nullptr;
}
inline bool ReadTreeRequest::has_state_root() const {
  return _internal_has_state_root();
}
inline void ReadTreeRequest::clear_state_root() {
  if (GetArena() == nullptr && state_root_ != nullptr) {
    delete state_root_;
  }
  state_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& ReadTreeRequest::_internal_state_root() const {
  const ::hashdb::v1::Fea* p = state_root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& ReadTreeRequest::state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ReadTreeRequest.state_root)
  return _internal_state_root();
}
inline void ReadTreeRequest::unsafe_arena_set_allocated_state_root(
    ::hashdb::v1::Fea* state_root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_root_);
  }
  state_root_ = state_root;
  if (state_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.ReadTreeRequest.state_root)
}
inline ::hashdb::v1::Fea* ReadTreeRequest::release_state_root() {
  auto temp = unsafe_arena_release_state_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* ReadTreeRequest::unsafe_arena_release_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.ReadTreeRequest.state_root)
  
  ::hashdb::v1::Fea* temp = state_root_;
  state_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* ReadTreeRequest::_internal_mutable_state_root() {
  
  if (state_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    state_root_ = p;
  }
  return state_root_;
}
inline ::hashdb::v1::Fea* ReadTreeRequest::mutable_state_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ReadTreeRequest.state_root)
  return _internal_mutable_state_root();
}
inline void ReadTreeRequest::set_allocated_state_root(::hashdb::v1::Fea* state_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete state_root_;
  }
  if (state_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(state_root);
    if (message_arena != submessage_arena) {
      state_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state_root, submessage_arena);
    }
    
  } else {
    
  }
  state_root_ = state_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.ReadTreeRequest.state_root)
}

// repeated .hashdb.v1.Fea keys = 2;
inline int ReadTreeRequest::_internal_keys_size() const {
  return keys_.size();
}
inline int ReadTreeRequest::keys_size() const {
  return _internal_keys_size();
}
inline void ReadTreeRequest::clear_keys() {
  keys_.Clear();
}
inline ::hashdb::v1::Fea* ReadTreeRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ReadTreeRequest.keys)
  return keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::Fea >*
ReadTreeRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.ReadTreeRequest.keys)
  return &keys_;
}
inline const ::hashdb::v1::Fea& ReadTreeRequest::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const ::hashdb::v1::Fea& ReadTreeRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ReadTreeRequest.keys)
  return _internal_keys(index);
}
inline ::hashdb::v1::Fea* ReadTreeRequest::_internal_add_keys() {
  return keys_.Add();
}
inline ::hashdb::v1::Fea* ReadTreeRequest::add_keys() {
  // @@protoc_insertion_point(field_add:hashdb.v1.ReadTreeRequest.keys)
  return _internal_add_keys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::Fea >&
ReadTreeRequest::keys() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.ReadTreeRequest.keys)
  return keys_;
}

// -------------------------------------------------------------------

// CancelBatchRequest

// string batch_uuid = 1;
inline void CancelBatchRequest::clear_batch_uuid() {
  batch_uuid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CancelBatchRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.CancelBatchRequest.batch_uuid)
  return _internal_batch_uuid();
}
inline void CancelBatchRequest::set_batch_uuid(const std::string& value) {
  _internal_set_batch_uuid(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.CancelBatchRequest.batch_uuid)
}
inline std::string* CancelBatchRequest::mutable_batch_uuid() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.CancelBatchRequest.batch_uuid)
  return _internal_mutable_batch_uuid();
}
inline const std::string& CancelBatchRequest::_internal_batch_uuid() const {
  return batch_uuid_.Get();
}
inline void CancelBatchRequest::_internal_set_batch_uuid(const std::string& value) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CancelBatchRequest::set_batch_uuid(std::string&& value) {
  
  batch_uuid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.CancelBatchRequest.batch_uuid)
}
inline void CancelBatchRequest::set_batch_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.CancelBatchRequest.batch_uuid)
}
inline void CancelBatchRequest::set_batch_uuid(const char* value,
    size_t size) {
  
  batch_uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.CancelBatchRequest.batch_uuid)
}
inline std::string* CancelBatchRequest::_internal_mutable_batch_uuid() {
  
  return batch_uuid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CancelBatchRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.CancelBatchRequest.batch_uuid)
  return batch_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CancelBatchRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), batch_uuid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.CancelBatchRequest.batch_uuid)
}
inline std::string* CancelBatchRequest::unsafe_arena_release_batch_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.CancelBatchRequest.batch_uuid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return batch_uuid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CancelBatchRequest::unsafe_arena_set_allocated_batch_uuid(
    std::string* batch_uuid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  batch_uuid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      batch_uuid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.CancelBatchRequest.batch_uuid)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SetResponse

// .hashdb.v1.Fea old_root = 1;
inline bool SetResponse::_internal_has_old_root() const {
  return this != internal_default_instance() && old_root_ != nullptr;
}
inline bool SetResponse::has_old_root() const {
  return _internal_has_old_root();
}
inline void SetResponse::clear_old_root() {
  if (GetArena() == nullptr && old_root_ != nullptr) {
    delete old_root_;
  }
  old_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_old_root() const {
  const ::hashdb::v1::Fea* p = old_root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::old_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.old_root)
  return _internal_old_root();
}
inline void SetResponse::unsafe_arena_set_allocated_old_root(
    ::hashdb::v1::Fea* old_root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_root_);
  }
  old_root_ = old_root;
  if (old_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.old_root)
}
inline ::hashdb::v1::Fea* SetResponse::release_old_root() {
  auto temp = unsafe_arena_release_old_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_old_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.old_root)
  
  ::hashdb::v1::Fea* temp = old_root_;
  old_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_old_root() {
  
  if (old_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    old_root_ = p;
  }
  return old_root_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_old_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.old_root)
  return _internal_mutable_old_root();
}
inline void SetResponse::set_allocated_old_root(::hashdb::v1::Fea* old_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete old_root_;
  }
  if (old_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(old_root);
    if (message_arena != submessage_arena) {
      old_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_root, submessage_arena);
    }
    
  } else {
    
  }
  old_root_ = old_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.old_root)
}

// .hashdb.v1.Fea new_root = 2;
inline bool SetResponse::_internal_has_new_root() const {
  return this != internal_default_instance() && new_root_ != nullptr;
}
inline bool SetResponse::has_new_root() const {
  return _internal_has_new_root();
}
inline void SetResponse::clear_new_root() {
  if (GetArena() == nullptr && new_root_ != nullptr) {
    delete new_root_;
  }
  new_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_new_root() const {
  const ::hashdb::v1::Fea* p = new_root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::new_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.new_root)
  return _internal_new_root();
}
inline void SetResponse::unsafe_arena_set_allocated_new_root(
    ::hashdb::v1::Fea* new_root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_root_);
  }
  new_root_ = new_root;
  if (new_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.new_root)
}
inline ::hashdb::v1::Fea* SetResponse::release_new_root() {
  auto temp = unsafe_arena_release_new_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_new_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.new_root)
  
  ::hashdb::v1::Fea* temp = new_root_;
  new_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_new_root() {
  
  if (new_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    new_root_ = p;
  }
  return new_root_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_new_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.new_root)
  return _internal_mutable_new_root();
}
inline void SetResponse::set_allocated_new_root(::hashdb::v1::Fea* new_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete new_root_;
  }
  if (new_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(new_root);
    if (message_arena != submessage_arena) {
      new_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_root, submessage_arena);
    }
    
  } else {
    
  }
  new_root_ = new_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.new_root)
}

// .hashdb.v1.Fea key = 3;
inline bool SetResponse::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool SetResponse::has_key() const {
  return _internal_has_key();
}
inline void SetResponse::clear_key() {
  if (GetArena() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_key() const {
  const ::hashdb::v1::Fea* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.key)
  return _internal_key();
}
inline void SetResponse::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.key)
}
inline ::hashdb::v1::Fea* SetResponse::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.key)
  
  ::hashdb::v1::Fea* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.key)
  return _internal_mutable_key();
}
inline void SetResponse::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.key)
}

// map<uint64, .hashdb.v1.SiblingList> siblings = 4;
inline int SetResponse::_internal_siblings_size() const {
  return siblings_.size();
}
inline int SetResponse::siblings_size() const {
  return _internal_siblings_size();
}
inline void SetResponse::clear_siblings() {
  siblings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
SetResponse::_internal_siblings() const {
  return siblings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
SetResponse::siblings() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.SetResponse.siblings)
  return _internal_siblings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
SetResponse::_internal_mutable_siblings() {
  return siblings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
SetResponse::mutable_siblings() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.SetResponse.siblings)
  return _internal_mutable_siblings();
}

// .hashdb.v1.Fea ins_key = 5;
inline bool SetResponse::_internal_has_ins_key() const {
  return this != internal_default_instance() && ins_key_ != nullptr;
}
inline bool SetResponse::has_ins_key() const {
  return _internal_has_ins_key();
}
inline void SetResponse::clear_ins_key() {
  if (GetArena() == nullptr && ins_key_ != nullptr) {
    delete ins_key_;
  }
  ins_key_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_ins_key() const {
  const ::hashdb::v1::Fea* p = ins_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::ins_key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.ins_key)
  return _internal_ins_key();
}
inline void SetResponse::unsafe_arena_set_allocated_ins_key(
    ::hashdb::v1::Fea* ins_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ins_key_);
  }
  ins_key_ = ins_key;
  if (ins_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.ins_key)
}
inline ::hashdb::v1::Fea* SetResponse::release_ins_key() {
  auto temp = unsafe_arena_release_ins_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_ins_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.ins_key)
  
  ::hashdb::v1::Fea* temp = ins_key_;
  ins_key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_ins_key() {
  
  if (ins_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    ins_key_ = p;
  }
  return ins_key_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_ins_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.ins_key)
  return _internal_mutable_ins_key();
}
inline void SetResponse::set_allocated_ins_key(::hashdb::v1::Fea* ins_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ins_key_;
  }
  if (ins_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ins_key);
    if (message_arena != submessage_arena) {
      ins_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ins_key, submessage_arena);
    }
    
  } else {
    
  }
  ins_key_ = ins_key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.ins_key)
}

// string ins_value = 6;
inline void SetResponse::clear_ins_value() {
  ins_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetResponse::ins_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.ins_value)
  return _internal_ins_value();
}
inline void SetResponse::set_ins_value(const std::string& value) {
  _internal_set_ins_value(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.ins_value)
}
inline std::string* SetResponse::mutable_ins_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.ins_value)
  return _internal_mutable_ins_value();
}
inline const std::string& SetResponse::_internal_ins_value() const {
  return ins_value_.Get();
}
inline void SetResponse::_internal_set_ins_value(const std::string& value) {
  
  ins_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetResponse::set_ins_value(std::string&& value) {
  
  ins_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetResponse.ins_value)
}
inline void SetResponse::set_ins_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ins_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetResponse.ins_value)
}
inline void SetResponse::set_ins_value(const char* value,
    size_t size) {
  
  ins_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetResponse.ins_value)
}
inline std::string* SetResponse::_internal_mutable_ins_value() {
  
  return ins_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetResponse::release_ins_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.ins_value)
  return ins_value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetResponse::set_allocated_ins_value(std::string* ins_value) {
  if (ins_value != nullptr) {
    
  } else {
    
  }
  ins_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ins_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.ins_value)
}
inline std::string* SetResponse::unsafe_arena_release_ins_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetResponse.ins_value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return ins_value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetResponse::unsafe_arena_set_allocated_ins_value(
    std::string* ins_value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ins_value != nullptr) {
    
  } else {
    
  }
  ins_value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ins_value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.ins_value)
}

// bool is_old0 = 7;
inline void SetResponse::clear_is_old0() {
  is_old0_ = false;
}
inline bool SetResponse::_internal_is_old0() const {
  return is_old0_;
}
inline bool SetResponse::is_old0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.is_old0)
  return _internal_is_old0();
}
inline void SetResponse::_internal_set_is_old0(bool value) {
  
  is_old0_ = value;
}
inline void SetResponse::set_is_old0(bool value) {
  _internal_set_is_old0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.is_old0)
}

// string old_value = 8;
inline void SetResponse::clear_old_value() {
  old_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetResponse::old_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.old_value)
  return _internal_old_value();
}
inline void SetResponse::set_old_value(const std::string& value) {
  _internal_set_old_value(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.old_value)
}
inline std::string* SetResponse::mutable_old_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.old_value)
  return _internal_mutable_old_value();
}
inline const std::string& SetResponse::_internal_old_value() const {
  return old_value_.Get();
}
inline void SetResponse::_internal_set_old_value(const std::string& value) {
  
  old_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetResponse::set_old_value(std::string&& value) {
  
  old_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetResponse.old_value)
}
inline void SetResponse::set_old_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  old_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetResponse.old_value)
}
inline void SetResponse::set_old_value(const char* value,
    size_t size) {
  
  old_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetResponse.old_value)
}
inline std::string* SetResponse::_internal_mutable_old_value() {
  
  return old_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetResponse::release_old_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.old_value)
  return old_value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetResponse::set_allocated_old_value(std::string* old_value) {
  if (old_value != nullptr) {
    
  } else {
    
  }
  old_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), old_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.old_value)
}
inline std::string* SetResponse::unsafe_arena_release_old_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetResponse.old_value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return old_value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetResponse::unsafe_arena_set_allocated_old_value(
    std::string* old_value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (old_value != nullptr) {
    
  } else {
    
  }
  old_value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      old_value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.old_value)
}

// string new_value = 9;
inline void SetResponse::clear_new_value() {
  new_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetResponse::new_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.new_value)
  return _internal_new_value();
}
inline void SetResponse::set_new_value(const std::string& value) {
  _internal_set_new_value(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.new_value)
}
inline std::string* SetResponse::mutable_new_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.new_value)
  return _internal_mutable_new_value();
}
inline const std::string& SetResponse::_internal_new_value() const {
  return new_value_.Get();
}
inline void SetResponse::_internal_set_new_value(const std::string& value) {
  
  new_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetResponse::set_new_value(std::string&& value) {
  
  new_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetResponse.new_value)
}
inline void SetResponse::set_new_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  new_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetResponse.new_value)
}
inline void SetResponse::set_new_value(const char* value,
    size_t size) {
  
  new_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetResponse.new_value)
}
inline std::string* SetResponse::_internal_mutable_new_value() {
  
  return new_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetResponse::release_new_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.new_value)
  return new_value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetResponse::set_allocated_new_value(std::string* new_value) {
  if (new_value != nullptr) {
    
  } else {
    
  }
  new_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.new_value)
}
inline std::string* SetResponse::unsafe_arena_release_new_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetResponse.new_value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return new_value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetResponse::unsafe_arena_set_allocated_new_value(
    std::string* new_value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (new_value != nullptr) {
    
  } else {
    
  }
  new_value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      new_value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.new_value)
}

// string mode = 10;
inline void SetResponse::clear_mode() {
  mode_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetResponse::mode() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.mode)
  return _internal_mode();
}
inline void SetResponse::set_mode(const std::string& value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.mode)
}
inline std::string* SetResponse::mutable_mode() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.mode)
  return _internal_mutable_mode();
}
inline const std::string& SetResponse::_internal_mode() const {
  return mode_.Get();
}
inline void SetResponse::_internal_set_mode(const std::string& value) {
  
  mode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetResponse::set_mode(std::string&& value) {
  
  mode_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.SetResponse.mode)
}
inline void SetResponse::set_mode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.SetResponse.mode)
}
inline void SetResponse::set_mode(const char* value,
    size_t size) {
  
  mode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.SetResponse.mode)
}
inline std::string* SetResponse::_internal_mutable_mode() {
  
  return mode_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetResponse::release_mode() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.mode)
  return mode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetResponse::set_allocated_mode(std::string* mode) {
  if (mode != nullptr) {
    
  } else {
    
  }
  mode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mode,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.mode)
}
inline std::string* SetResponse::unsafe_arena_release_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.SetResponse.mode)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return mode_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetResponse::unsafe_arena_set_allocated_mode(
    std::string* mode) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (mode != nullptr) {
    
  } else {
    
  }
  mode_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      mode, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.mode)
}

// uint64 proof_hash_counter = 11;
inline void SetResponse::clear_proof_hash_counter() {
  proof_hash_counter_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetResponse::_internal_proof_hash_counter() const {
  return proof_hash_counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetResponse::proof_hash_counter() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.proof_hash_counter)
  return _internal_proof_hash_counter();
}
inline void SetResponse::_internal_set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  proof_hash_counter_ = value;
}
inline void SetResponse::set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_proof_hash_counter(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.proof_hash_counter)
}

// map<string, .hashdb.v1.FeList> db_read_log = 12;
inline int SetResponse::_internal_db_read_log_size() const {
  return db_read_log_.size();
}
inline int SetResponse::db_read_log_size() const {
  return _internal_db_read_log_size();
}
inline void SetResponse::clear_db_read_log() {
  db_read_log_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
SetResponse::_internal_db_read_log() const {
  return db_read_log_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
SetResponse::db_read_log() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.SetResponse.db_read_log)
  return _internal_db_read_log();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
SetResponse::_internal_mutable_db_read_log() {
  return db_read_log_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
SetResponse::mutable_db_read_log() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.SetResponse.db_read_log)
  return _internal_mutable_db_read_log();
}

// .hashdb.v1.ResultCode result = 13;
inline bool SetResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool SetResponse::has_result() const {
  return _internal_has_result();
}
inline void SetResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& SetResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& SetResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.result)
  return _internal_result();
}
inline void SetResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.result)
}
inline ::hashdb::v1::ResultCode* SetResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* SetResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* SetResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* SetResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.result)
  return _internal_mutable_result();
}
inline void SetResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.result)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetResponse

// .hashdb.v1.Fea root = 1;
inline bool GetResponse::_internal_has_root() const {
  return this != internal_default_instance() && root_ != nullptr;
}
inline bool GetResponse::has_root() const {
  return _internal_has_root();
}
inline void GetResponse::clear_root() {
  if (GetArena() == nullptr && root_ != nullptr) {
    delete root_;
  }
  root_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetResponse::_internal_root() const {
  const ::hashdb::v1::Fea* p = root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetResponse::root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.root)
  return _internal_root();
}
inline void GetResponse::unsafe_arena_set_allocated_root(
    ::hashdb::v1::Fea* root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(root_);
  }
  root_ = root;
  if (root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.root)
}
inline ::hashdb::v1::Fea* GetResponse::release_root() {
  auto temp = unsafe_arena_release_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.root)
  
  ::hashdb::v1::Fea* temp = root_;
  root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::_internal_mutable_root() {
  
  if (root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    root_ = p;
  }
  return root_;
}
inline ::hashdb::v1::Fea* GetResponse::mutable_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.root)
  return _internal_mutable_root();
}
inline void GetResponse::set_allocated_root(::hashdb::v1::Fea* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete root_;
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(root);
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    
  } else {
    
  }
  root_ = root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.root)
}

// .hashdb.v1.Fea key = 2;
inline bool GetResponse::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool GetResponse::has_key() const {
  return _internal_has_key();
}
inline void GetResponse::clear_key() {
  if (GetArena() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetResponse::_internal_key() const {
  const ::hashdb::v1::Fea* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetResponse::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.key)
  return _internal_key();
}
inline void GetResponse::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.key)
}
inline ::hashdb::v1::Fea* GetResponse::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.key)
  
  ::hashdb::v1::Fea* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::hashdb::v1::Fea* GetResponse::mutable_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.key)
  return _internal_mutable_key();
}
inline void GetResponse::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.key)
}

// map<uint64, .hashdb.v1.SiblingList> siblings = 3;
inline int GetResponse::_internal_siblings_size() const {
  return siblings_.size();
}
inline int GetResponse::siblings_size() const {
  return _internal_siblings_size();
}
inline void GetResponse::clear_siblings() {
  siblings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
GetResponse::_internal_siblings() const {
  return siblings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >&
GetResponse::siblings() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetResponse.siblings)
  return _internal_siblings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
GetResponse::_internal_mutable_siblings() {
  return siblings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::hashdb::v1::SiblingList >*
GetResponse::mutable_siblings() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetResponse.siblings)
  return _internal_mutable_siblings();
}

// .hashdb.v1.Fea ins_key = 4;
inline bool GetResponse::_internal_has_ins_key() const {
  return this != internal_default_instance() && ins_key_ != nullptr;
}
inline bool GetResponse::has_ins_key() const {
  return _internal_has_ins_key();
}
inline void GetResponse::clear_ins_key() {
  if (GetArena() == nullptr && ins_key_ != nullptr) {
    delete ins_key_;
  }
  ins_key_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetResponse::_internal_ins_key() const {
  const ::hashdb::v1::Fea* p = ins_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetResponse::ins_key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.ins_key)
  return _internal_ins_key();
}
inline void GetResponse::unsafe_arena_set_allocated_ins_key(
    ::hashdb::v1::Fea* ins_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ins_key_);
  }
  ins_key_ = ins_key;
  if (ins_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.ins_key)
}
inline ::hashdb::v1::Fea* GetResponse::release_ins_key() {
  auto temp = unsafe_arena_release_ins_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::unsafe_arena_release_ins_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.ins_key)
  
  ::hashdb::v1::Fea* temp = ins_key_;
  ins_key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::_internal_mutable_ins_key() {
  
  if (ins_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    ins_key_ = p;
  }
  return ins_key_;
}
inline ::hashdb::v1::Fea* GetResponse::mutable_ins_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.ins_key)
  return _internal_mutable_ins_key();
}
inline void GetResponse::set_allocated_ins_key(::hashdb::v1::Fea* ins_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ins_key_;
  }
  if (ins_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ins_key);
    if (message_arena != submessage_arena) {
      ins_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ins_key, submessage_arena);
    }
    
  } else {
    
  }
  ins_key_ = ins_key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.ins_key)
}

// string ins_value = 5;
inline void GetResponse::clear_ins_value() {
  ins_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetResponse::ins_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.ins_value)
  return _internal_ins_value();
}
inline void GetResponse::set_ins_value(const std::string& value) {
  _internal_set_ins_value(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.ins_value)
}
inline std::string* GetResponse::mutable_ins_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.ins_value)
  return _internal_mutable_ins_value();
}
inline const std::string& GetResponse::_internal_ins_value() const {
  return ins_value_.Get();
}
inline void GetResponse::_internal_set_ins_value(const std::string& value) {
  
  ins_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetResponse::set_ins_value(std::string&& value) {
  
  ins_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.GetResponse.ins_value)
}
inline void GetResponse::set_ins_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ins_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.GetResponse.ins_value)
}
inline void GetResponse::set_ins_value(const char* value,
    size_t size) {
  
  ins_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.GetResponse.ins_value)
}
inline std::string* GetResponse::_internal_mutable_ins_value() {
  
  return ins_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetResponse::release_ins_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.ins_value)
  return ins_value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponse::set_allocated_ins_value(std::string* ins_value) {
  if (ins_value != nullptr) {
    
  } else {
    
  }
  ins_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ins_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.ins_value)
}
inline std::string* GetResponse::unsafe_arena_release_ins_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.GetResponse.ins_value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return ins_value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetResponse::unsafe_arena_set_allocated_ins_value(
    std::string* ins_value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ins_value != nullptr) {
    
  } else {
    
  }
  ins_value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ins_value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.ins_value)
}

// bool is_old0 = 6;
inline void GetResponse::clear_is_old0() {
  is_old0_ = false;
}
inline bool GetResponse::_internal_is_old0() const {
  return is_old0_;
}
inline bool GetResponse::is_old0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.is_old0)
  return _internal_is_old0();
}
inline void GetResponse::_internal_set_is_old0(bool value) {
  
  is_old0_ = value;
}
inline void GetResponse::set_is_old0(bool value) {
  _internal_set_is_old0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.is_old0)
}

// string value = 7;
inline void GetResponse::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.value)
  return _internal_value();
}
inline void GetResponse::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.value)
}
inline std::string* GetResponse::mutable_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.value)
  return _internal_mutable_value();
}
inline const std::string& GetResponse::_internal_value() const {
  return value_.Get();
}
inline void GetResponse::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetResponse::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.GetResponse.value)
}
inline void GetResponse::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.GetResponse.value)
}
inline void GetResponse::set_value(const char* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.GetResponse.value)
}
inline std::string* GetResponse::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetResponse::release_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.value)
}
inline std::string* GetResponse::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.GetResponse.value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetResponse::unsafe_arena_set_allocated_value(
    std::string* value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (value != nullptr) {
    
  } else {
    
  }
  value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.value)
}

// uint64 proof_hash_counter = 8;
inline void GetResponse::clear_proof_hash_counter() {
  proof_hash_counter_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetResponse::_internal_proof_hash_counter() const {
  return proof_hash_counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetResponse::proof_hash_counter() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.proof_hash_counter)
  return _internal_proof_hash_counter();
}
inline void GetResponse::_internal_set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  proof_hash_counter_ = value;
}
inline void GetResponse::set_proof_hash_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_proof_hash_counter(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.proof_hash_counter)
}

// map<string, .hashdb.v1.FeList> db_read_log = 9;
inline int GetResponse::_internal_db_read_log_size() const {
  return db_read_log_.size();
}
inline int GetResponse::db_read_log_size() const {
  return _internal_db_read_log_size();
}
inline void GetResponse::clear_db_read_log() {
  db_read_log_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
GetResponse::_internal_db_read_log() const {
  return db_read_log_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
GetResponse::db_read_log() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetResponse.db_read_log)
  return _internal_db_read_log();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
GetResponse::_internal_mutable_db_read_log() {
  return db_read_log_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
GetResponse::mutable_db_read_log() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetResponse.db_read_log)
  return _internal_mutable_db_read_log();
}

// .hashdb.v1.ResultCode result = 10;
inline bool GetResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool GetResponse::has_result() const {
  return _internal_has_result();
}
inline void GetResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& GetResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& GetResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.result)
  return _internal_result();
}
inline void GetResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.result)
}
inline ::hashdb::v1::ResultCode* GetResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* GetResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* GetResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* GetResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.result)
  return _internal_mutable_result();
}
inline void GetResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.result)
}

// -------------------------------------------------------------------

// SetProgramResponse

// .hashdb.v1.ResultCode result = 1;
inline bool SetProgramResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool SetProgramResponse::has_result() const {
  return _internal_has_result();
}
inline void SetProgramResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& SetProgramResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& SetProgramResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramResponse.result)
  return _internal_result();
}
inline void SetProgramResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetProgramResponse.result)
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetProgramResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetProgramResponse.result)
  return _internal_mutable_result();
}
inline void SetProgramResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetProgramResponse.result)
}

// -------------------------------------------------------------------

// GetProgramResponse

// bytes data = 1;
inline void GetProgramResponse::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetProgramResponse::data() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetProgramResponse.data)
  return _internal_data();
}
inline void GetProgramResponse::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetProgramResponse.data)
}
inline std::string* GetProgramResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetProgramResponse.data)
  return _internal_mutable_data();
}
inline const std::string& GetProgramResponse::_internal_data() const {
  return data_.Get();
}
inline void GetProgramResponse::_internal_set_data(const std::string& value) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetProgramResponse::set_data(std::string&& value) {
  
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.GetProgramResponse.data)
}
inline void GetProgramResponse::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.GetProgramResponse.data)
}
inline void GetProgramResponse::set_data(const void* value,
    size_t size) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.GetProgramResponse.data)
}
inline std::string* GetProgramResponse::_internal_mutable_data() {
  
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetProgramResponse::release_data() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetProgramResponse.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetProgramResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetProgramResponse.data)
}
inline std::string* GetProgramResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.GetProgramResponse.data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetProgramResponse::unsafe_arena_set_allocated_data(
    std::string* data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data != nullptr) {
    
  } else {
    
  }
  data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetProgramResponse.data)
}

// .hashdb.v1.ResultCode result = 2;
inline bool GetProgramResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool GetProgramResponse::has_result() const {
  return _internal_has_result();
}
inline void GetProgramResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& GetProgramResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& GetProgramResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetProgramResponse.result)
  return _internal_result();
}
inline void GetProgramResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetProgramResponse.result)
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetProgramResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetProgramResponse.result)
  return _internal_mutable_result();
}
inline void GetProgramResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetProgramResponse.result)
}

// -------------------------------------------------------------------

// FlushResponse

// uint64 flush_id = 1;
inline void FlushResponse::clear_flush_id() {
  flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FlushResponse::_internal_flush_id() const {
  return flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FlushResponse::flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushResponse.flush_id)
  return _internal_flush_id();
}
inline void FlushResponse::_internal_set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  flush_id_ = value;
}
inline void FlushResponse::set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushResponse.flush_id)
}

// uint64 stored_flush_id = 2;
inline void FlushResponse::clear_stored_flush_id() {
  stored_flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FlushResponse::_internal_stored_flush_id() const {
  return stored_flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FlushResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void FlushResponse::_internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  stored_flush_id_ = value;
}
inline void FlushResponse::set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushResponse.stored_flush_id)
}

// .hashdb.v1.ResultCode result = 3;
inline bool FlushResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool FlushResponse::has_result() const {
  return _internal_has_result();
}
inline void FlushResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& FlushResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& FlushResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushResponse.result)
  return _internal_result();
}
inline void FlushResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.FlushResponse.result)
}
inline ::hashdb::v1::ResultCode* FlushResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* FlushResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FlushResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* FlushResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* FlushResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FlushResponse.result)
  return _internal_mutable_result();
}
inline void FlushResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FlushResponse.result)
}

// -------------------------------------------------------------------

// GetFlushStatusResponse

// uint64 stored_flush_id = 1;
inline void GetFlushStatusResponse::clear_stored_flush_id() {
  stored_flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_stored_flush_id() const {
  return stored_flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  stored_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.stored_flush_id)
}

// uint64 storing_flush_id = 2;
inline void GetFlushStatusResponse::clear_storing_flush_id() {
  storing_flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_storing_flush_id() const {
  return storing_flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::storing_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.storing_flush_id)
  return _internal_storing_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_storing_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  storing_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_storing_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_storing_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.storing_flush_id)
}

// uint64 last_flush_id = 3;
inline void GetFlushStatusResponse::clear_last_flush_id() {
  last_flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_last_flush_id() const {
  return last_flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::last_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.last_flush_id)
  return _internal_last_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_last_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  last_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_last_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.last_flush_id)
}

// uint64 pending_to_flush_nodes = 4;
inline void GetFlushStatusResponse::clear_pending_to_flush_nodes() {
  pending_to_flush_nodes_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_pending_to_flush_nodes() const {
  return pending_to_flush_nodes_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::pending_to_flush_nodes() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.pending_to_flush_nodes)
  return _internal_pending_to_flush_nodes();
}
inline void GetFlushStatusResponse::_internal_set_pending_to_flush_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  pending_to_flush_nodes_ = value;
}
inline void GetFlushStatusResponse::set_pending_to_flush_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_pending_to_flush_nodes(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.pending_to_flush_nodes)
}

// uint64 pending_to_flush_program = 5;
inline void GetFlushStatusResponse::clear_pending_to_flush_program() {
  pending_to_flush_program_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_pending_to_flush_program() const {
  return pending_to_flush_program_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::pending_to_flush_program() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.pending_to_flush_program)
  return _internal_pending_to_flush_program();
}
inline void GetFlushStatusResponse::_internal_set_pending_to_flush_program(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  pending_to_flush_program_ = value;
}
inline void GetFlushStatusResponse::set_pending_to_flush_program(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_pending_to_flush_program(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.pending_to_flush_program)
}

// uint64 storing_nodes = 6;
inline void GetFlushStatusResponse::clear_storing_nodes() {
  storing_nodes_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_storing_nodes() const {
  return storing_nodes_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::storing_nodes() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.storing_nodes)
  return _internal_storing_nodes();
}
inline void GetFlushStatusResponse::_internal_set_storing_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  storing_nodes_ = value;
}
inline void GetFlushStatusResponse::set_storing_nodes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_storing_nodes(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.storing_nodes)
}

// uint64 storing_program = 7;
inline void GetFlushStatusResponse::clear_storing_program() {
  storing_program_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::_internal_storing_program() const {
  return storing_program_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushStatusResponse::storing_program() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.storing_program)
  return _internal_storing_program();
}
inline void GetFlushStatusResponse::_internal_set_storing_program(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  storing_program_ = value;
}
inline void GetFlushStatusResponse::set_storing_program(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_storing_program(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.storing_program)
}

// string prover_id = 8;
inline void GetFlushStatusResponse::clear_prover_id() {
  prover_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetFlushStatusResponse::prover_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.prover_id)
  return _internal_prover_id();
}
inline void GetFlushStatusResponse::set_prover_id(const std::string& value) {
  _internal_set_prover_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.prover_id)
}
inline std::string* GetFlushStatusResponse::mutable_prover_id() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetFlushStatusResponse.prover_id)
  return _internal_mutable_prover_id();
}
inline const std::string& GetFlushStatusResponse::_internal_prover_id() const {
  return prover_id_.Get();
}
inline void GetFlushStatusResponse::_internal_set_prover_id(const std::string& value) {
  
  prover_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetFlushStatusResponse::set_prover_id(std::string&& value) {
  
  prover_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.GetFlushStatusResponse.prover_id)
}
inline void GetFlushStatusResponse::set_prover_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  prover_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.GetFlushStatusResponse.prover_id)
}
inline void GetFlushStatusResponse::set_prover_id(const char* value,
    size_t size) {
  
  prover_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.GetFlushStatusResponse.prover_id)
}
inline std::string* GetFlushStatusResponse::_internal_mutable_prover_id() {
  
  return prover_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetFlushStatusResponse::release_prover_id() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetFlushStatusResponse.prover_id)
  return prover_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetFlushStatusResponse::set_allocated_prover_id(std::string* prover_id) {
  if (prover_id != nullptr) {
    
  } else {
    
  }
  prover_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prover_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetFlushStatusResponse.prover_id)
}
inline std::string* GetFlushStatusResponse::unsafe_arena_release_prover_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.GetFlushStatusResponse.prover_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return prover_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetFlushStatusResponse::unsafe_arena_set_allocated_prover_id(
    std::string* prover_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (prover_id != nullptr) {
    
  } else {
    
  }
  prover_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      prover_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetFlushStatusResponse.prover_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetFlushDataResponse

// uint64 stored_flush_id = 1;
inline void GetFlushDataResponse::clear_stored_flush_id() {
  stored_flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushDataResponse::_internal_stored_flush_id() const {
  return stored_flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFlushDataResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void GetFlushDataResponse::_internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  stored_flush_id_ = value;
}
inline void GetFlushDataResponse::set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushDataResponse.stored_flush_id)
}

// map<string, string> nodes = 2;
inline int GetFlushDataResponse::_internal_nodes_size() const {
  return nodes_.size();
}
inline int GetFlushDataResponse::nodes_size() const {
  return _internal_nodes_size();
}
inline void GetFlushDataResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::_internal_nodes() const {
  return nodes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::nodes() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetFlushDataResponse.nodes)
  return _internal_nodes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::_internal_mutable_nodes() {
  return nodes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetFlushDataResponse.nodes)
  return _internal_mutable_nodes();
}

// map<string, string> program = 3;
inline int GetFlushDataResponse::_internal_program_size() const {
  return program_.size();
}
inline int GetFlushDataResponse::program_size() const {
  return _internal_program_size();
}
inline void GetFlushDataResponse::clear_program() {
  program_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::_internal_program() const {
  return program_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::program() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetFlushDataResponse.program)
  return _internal_program();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::_internal_mutable_program() {
  return program_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::mutable_program() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetFlushDataResponse.program)
  return _internal_mutable_program();
}

// string nodes_state_root = 4;
inline void GetFlushDataResponse::clear_nodes_state_root() {
  nodes_state_root_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetFlushDataResponse::nodes_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  return _internal_nodes_state_root();
}
inline void GetFlushDataResponse::set_nodes_state_root(const std::string& value) {
  _internal_set_nodes_state_root(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}
inline std::string* GetFlushDataResponse::mutable_nodes_state_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  return _internal_mutable_nodes_state_root();
}
inline const std::string& GetFlushDataResponse::_internal_nodes_state_root() const {
  return nodes_state_root_.Get();
}
inline void GetFlushDataResponse::_internal_set_nodes_state_root(const std::string& value) {
  
  nodes_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetFlushDataResponse::set_nodes_state_root(std::string&& value) {
  
  nodes_state_root_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}
inline void GetFlushDataResponse::set_nodes_state_root(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  nodes_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}
inline void GetFlushDataResponse::set_nodes_state_root(const char* value,
    size_t size) {
  
  nodes_state_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}
inline std::string* GetFlushDataResponse::_internal_mutable_nodes_state_root() {
  
  return nodes_state_root_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetFlushDataResponse::release_nodes_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  return nodes_state_root_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetFlushDataResponse::set_allocated_nodes_state_root(std::string* nodes_state_root) {
  if (nodes_state_root != nullptr) {
    
  } else {
    
  }
  nodes_state_root_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodes_state_root,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}
inline std::string* GetFlushDataResponse::unsafe_arena_release_nodes_state_root() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return nodes_state_root_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetFlushDataResponse::unsafe_arena_set_allocated_nodes_state_root(
    std::string* nodes_state_root) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (nodes_state_root != nullptr) {
    
  } else {
    
  }
  nodes_state_root_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      nodes_state_root, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}

// .hashdb.v1.ResultCode result = 5;
inline bool GetFlushDataResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool GetFlushDataResponse::has_result() const {
  return _internal_has_result();
}
inline void GetFlushDataResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& GetFlushDataResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& GetFlushDataResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataResponse.result)
  return _internal_result();
}
inline void GetFlushDataResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetFlushDataResponse.result)
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetFlushDataResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetFlushDataResponse.result)
  return _internal_mutable_result();
}
inline void GetFlushDataResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetFlushDataResponse.result)
}

// -------------------------------------------------------------------

// ConsolidateStateResponse

// .hashdb.v1.Fea consolidated_state_root = 1;
inline bool ConsolidateStateResponse::_internal_has_consolidated_state_root() const {
  return this != internal_default_instance() && consolidated_state_root_ != nullptr;
}
inline bool ConsolidateStateResponse::has_consolidated_state_root() const {
  return _internal_has_consolidated_state_root();
}
inline void ConsolidateStateResponse::clear_consolidated_state_root() {
  if (GetArena() == nullptr && consolidated_state_root_ != nullptr) {
    delete consolidated_state_root_;
  }
  consolidated_state_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& ConsolidateStateResponse::_internal_consolidated_state_root() const {
  const ::hashdb::v1::Fea* p = consolidated_state_root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& ConsolidateStateResponse::consolidated_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ConsolidateStateResponse.consolidated_state_root)
  return _internal_consolidated_state_root();
}
inline void ConsolidateStateResponse::unsafe_arena_set_allocated_consolidated_state_root(
    ::hashdb::v1::Fea* consolidated_state_root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(consolidated_state_root_);
  }
  consolidated_state_root_ = consolidated_state_root;
  if (consolidated_state_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.ConsolidateStateResponse.consolidated_state_root)
}
inline ::hashdb::v1::Fea* ConsolidateStateResponse::release_consolidated_state_root() {
  auto temp = unsafe_arena_release_consolidated_state_root();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* ConsolidateStateResponse::unsafe_arena_release_consolidated_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.ConsolidateStateResponse.consolidated_state_root)
  
  ::hashdb::v1::Fea* temp = consolidated_state_root_;
  consolidated_state_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* ConsolidateStateResponse::_internal_mutable_consolidated_state_root() {
  
  if (consolidated_state_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    consolidated_state_root_ = p;
  }
  return consolidated_state_root_;
}
inline ::hashdb::v1::Fea* ConsolidateStateResponse::mutable_consolidated_state_root() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ConsolidateStateResponse.consolidated_state_root)
  return _internal_mutable_consolidated_state_root();
}
inline void ConsolidateStateResponse::set_allocated_consolidated_state_root(::hashdb::v1::Fea* consolidated_state_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete consolidated_state_root_;
  }
  if (consolidated_state_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(consolidated_state_root);
    if (message_arena != submessage_arena) {
      consolidated_state_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consolidated_state_root, submessage_arena);
    }
    
  } else {
    
  }
  consolidated_state_root_ = consolidated_state_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.ConsolidateStateResponse.consolidated_state_root)
}

// uint64 flush_id = 2;
inline void ConsolidateStateResponse::clear_flush_id() {
  flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ConsolidateStateResponse::_internal_flush_id() const {
  return flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ConsolidateStateResponse::flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ConsolidateStateResponse.flush_id)
  return _internal_flush_id();
}
inline void ConsolidateStateResponse::_internal_set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  flush_id_ = value;
}
inline void ConsolidateStateResponse::set_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.ConsolidateStateResponse.flush_id)
}

// uint64 stored_flush_id = 3;
inline void ConsolidateStateResponse::clear_stored_flush_id() {
  stored_flush_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ConsolidateStateResponse::_internal_stored_flush_id() const {
  return stored_flush_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ConsolidateStateResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ConsolidateStateResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void ConsolidateStateResponse::_internal_set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  stored_flush_id_ = value;
}
inline void ConsolidateStateResponse::set_stored_flush_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.ConsolidateStateResponse.stored_flush_id)
}

// .hashdb.v1.ResultCode result = 4;
inline bool ConsolidateStateResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool ConsolidateStateResponse::has_result() const {
  return _internal_has_result();
}
inline void ConsolidateStateResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& ConsolidateStateResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& ConsolidateStateResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ConsolidateStateResponse.result)
  return _internal_result();
}
inline void ConsolidateStateResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.ConsolidateStateResponse.result)
}
inline ::hashdb::v1::ResultCode* ConsolidateStateResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* ConsolidateStateResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.ConsolidateStateResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* ConsolidateStateResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* ConsolidateStateResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ConsolidateStateResponse.result)
  return _internal_mutable_result();
}
inline void ConsolidateStateResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.ConsolidateStateResponse.result)
}

// -------------------------------------------------------------------

// PurgeResponse

// .hashdb.v1.ResultCode result = 1;
inline bool PurgeResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool PurgeResponse::has_result() const {
  return _internal_has_result();
}
inline void PurgeResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& PurgeResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& PurgeResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.PurgeResponse.result)
  return _internal_result();
}
inline void PurgeResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.PurgeResponse.result)
}
inline ::hashdb::v1::ResultCode* PurgeResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* PurgeResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.PurgeResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* PurgeResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* PurgeResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.PurgeResponse.result)
  return _internal_mutable_result();
}
inline void PurgeResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.PurgeResponse.result)
}

// -------------------------------------------------------------------

// ReadTreeResponse

// repeated .hashdb.v1.KeyValue key_value = 1;
inline int ReadTreeResponse::_internal_key_value_size() const {
  return key_value_.size();
}
inline int ReadTreeResponse::key_value_size() const {
  return _internal_key_value_size();
}
inline void ReadTreeResponse::clear_key_value() {
  key_value_.Clear();
}
inline ::hashdb::v1::KeyValue* ReadTreeResponse::mutable_key_value(int index) {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ReadTreeResponse.key_value)
  return key_value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::KeyValue >*
ReadTreeResponse::mutable_key_value() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.ReadTreeResponse.key_value)
  return &key_value_;
}
inline const ::hashdb::v1::KeyValue& ReadTreeResponse::_internal_key_value(int index) const {
  return key_value_.Get(index);
}
inline const ::hashdb::v1::KeyValue& ReadTreeResponse::key_value(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ReadTreeResponse.key_value)
  return _internal_key_value(index);
}
inline ::hashdb::v1::KeyValue* ReadTreeResponse::_internal_add_key_value() {
  return key_value_.Add();
}
inline ::hashdb::v1::KeyValue* ReadTreeResponse::add_key_value() {
  // @@protoc_insertion_point(field_add:hashdb.v1.ReadTreeResponse.key_value)
  return _internal_add_key_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::KeyValue >&
ReadTreeResponse::key_value() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.ReadTreeResponse.key_value)
  return key_value_;
}

// repeated .hashdb.v1.HashValueGL hash_value = 2;
inline int ReadTreeResponse::_internal_hash_value_size() const {
  return hash_value_.size();
}
inline int ReadTreeResponse::hash_value_size() const {
  return _internal_hash_value_size();
}
inline void ReadTreeResponse::clear_hash_value() {
  hash_value_.Clear();
}
inline ::hashdb::v1::HashValueGL* ReadTreeResponse::mutable_hash_value(int index) {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ReadTreeResponse.hash_value)
  return hash_value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::HashValueGL >*
ReadTreeResponse::mutable_hash_value() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.ReadTreeResponse.hash_value)
  return &hash_value_;
}
inline const ::hashdb::v1::HashValueGL& ReadTreeResponse::_internal_hash_value(int index) const {
  return hash_value_.Get(index);
}
inline const ::hashdb::v1::HashValueGL& ReadTreeResponse::hash_value(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ReadTreeResponse.hash_value)
  return _internal_hash_value(index);
}
inline ::hashdb::v1::HashValueGL* ReadTreeResponse::_internal_add_hash_value() {
  return hash_value_.Add();
}
inline ::hashdb::v1::HashValueGL* ReadTreeResponse::add_hash_value() {
  // @@protoc_insertion_point(field_add:hashdb.v1.ReadTreeResponse.hash_value)
  return _internal_add_hash_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::HashValueGL >&
ReadTreeResponse::hash_value() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.ReadTreeResponse.hash_value)
  return hash_value_;
}

// .hashdb.v1.ResultCode result = 3;
inline bool ReadTreeResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool ReadTreeResponse::has_result() const {
  return _internal_has_result();
}
inline void ReadTreeResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& ReadTreeResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& ReadTreeResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ReadTreeResponse.result)
  return _internal_result();
}
inline void ReadTreeResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.ReadTreeResponse.result)
}
inline ::hashdb::v1::ResultCode* ReadTreeResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* ReadTreeResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.ReadTreeResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* ReadTreeResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* ReadTreeResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ReadTreeResponse.result)
  return _internal_mutable_result();
}
inline void ReadTreeResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.ReadTreeResponse.result)
}

// -------------------------------------------------------------------

// CancelBatchResponse

// .hashdb.v1.ResultCode result = 1;
inline bool CancelBatchResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool CancelBatchResponse::has_result() const {
  return _internal_has_result();
}
inline void CancelBatchResponse::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& CancelBatchResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::ResultCode*>(
      &::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& CancelBatchResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.CancelBatchResponse.result)
  return _internal_result();
}
inline void CancelBatchResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.CancelBatchResponse.result)
}
inline ::hashdb::v1::ResultCode* CancelBatchResponse::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::ResultCode* CancelBatchResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.CancelBatchResponse.result)
  
  ::hashdb::v1::ResultCode* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* CancelBatchResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::hashdb::v1::ResultCode* CancelBatchResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.CancelBatchResponse.result)
  return _internal_mutable_result();
}
inline void CancelBatchResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.CancelBatchResponse.result)
}

// -------------------------------------------------------------------

// Fea

// uint64 fe0 = 1;
inline void Fea::clear_fe0() {
  fe0_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::_internal_fe0() const {
  return fe0_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::fe0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe0)
  return _internal_fe0();
}
inline void Fea::_internal_set_fe0(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe0_ = value;
}
inline void Fea::set_fe0(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe0)
}

// uint64 fe1 = 2;
inline void Fea::clear_fe1() {
  fe1_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::_internal_fe1() const {
  return fe1_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::fe1() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe1)
  return _internal_fe1();
}
inline void Fea::_internal_set_fe1(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe1_ = value;
}
inline void Fea::set_fe1(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe1(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe1)
}

// uint64 fe2 = 3;
inline void Fea::clear_fe2() {
  fe2_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::_internal_fe2() const {
  return fe2_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::fe2() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe2)
  return _internal_fe2();
}
inline void Fea::_internal_set_fe2(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe2_ = value;
}
inline void Fea::set_fe2(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe2(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe2)
}

// uint64 fe3 = 4;
inline void Fea::clear_fe3() {
  fe3_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::_internal_fe3() const {
  return fe3_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea::fe3() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe3)
  return _internal_fe3();
}
inline void Fea::_internal_set_fe3(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe3_ = value;
}
inline void Fea::set_fe3(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe3(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe3)
}

// -------------------------------------------------------------------

// Fea12

// uint64 fe0 = 1;
inline void Fea12::clear_fe0() {
  fe0_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::_internal_fe0() const {
  return fe0_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::fe0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe0)
  return _internal_fe0();
}
inline void Fea12::_internal_set_fe0(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe0_ = value;
}
inline void Fea12::set_fe0(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe0)
}

// uint64 fe1 = 2;
inline void Fea12::clear_fe1() {
  fe1_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::_internal_fe1() const {
  return fe1_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::fe1() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe1)
  return _internal_fe1();
}
inline void Fea12::_internal_set_fe1(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe1_ = value;
}
inline void Fea12::set_fe1(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe1(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe1)
}

// uint64 fe2 = 3;
inline void Fea12::clear_fe2() {
  fe2_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::_internal_fe2() const {
  return fe2_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::fe2() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe2)
  return _internal_fe2();
}
inline void Fea12::_internal_set_fe2(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe2_ = value;
}
inline void Fea12::set_fe2(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe2(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe2)
}

// uint64 fe3 = 4;
inline void Fea12::clear_fe3() {
  fe3_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::_internal_fe3() const {
  return fe3_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::fe3() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe3)
  return _internal_fe3();
}
inline void Fea12::_internal_set_fe3(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe3_ = value;
}
inline void Fea12::set_fe3(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe3(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe3)
}

// uint64 fe4 = 5;
inline void Fea12::clear_fe4() {
  fe4_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::_internal_fe4() const {
  return fe4_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::fe4() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe4)
  return _internal_fe4();
}
inline void Fea12::_internal_set_fe4(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe4_ = value;
}
inline void Fea12::set_fe4(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe4(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe4)
}

// uint64 fe5 = 6;
inline void Fea12::clear_fe5() {
  fe5_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::_internal_fe5() const {
  return fe5_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::fe5() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe5)
  return _internal_fe5();
}
inline void Fea12::_internal_set_fe5(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe5_ = value;
}
inline void Fea12::set_fe5(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe5(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe5)
}

// uint64 fe6 = 7;
inline void Fea12::clear_fe6() {
  fe6_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::_internal_fe6() const {
  return fe6_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::fe6() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe6)
  return _internal_fe6();
}
inline void Fea12::_internal_set_fe6(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe6_ = value;
}
inline void Fea12::set_fe6(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe6(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe6)
}

// uint64 fe7 = 8;
inline void Fea12::clear_fe7() {
  fe7_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::_internal_fe7() const {
  return fe7_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::fe7() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe7)
  return _internal_fe7();
}
inline void Fea12::_internal_set_fe7(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe7_ = value;
}
inline void Fea12::set_fe7(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe7(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe7)
}

// uint64 fe8 = 9;
inline void Fea12::clear_fe8() {
  fe8_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::_internal_fe8() const {
  return fe8_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::fe8() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe8)
  return _internal_fe8();
}
inline void Fea12::_internal_set_fe8(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe8_ = value;
}
inline void Fea12::set_fe8(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe8(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe8)
}

// uint64 fe9 = 10;
inline void Fea12::clear_fe9() {
  fe9_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::_internal_fe9() const {
  return fe9_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::fe9() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe9)
  return _internal_fe9();
}
inline void Fea12::_internal_set_fe9(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe9_ = value;
}
inline void Fea12::set_fe9(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe9(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe9)
}

// uint64 fe10 = 11;
inline void Fea12::clear_fe10() {
  fe10_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::_internal_fe10() const {
  return fe10_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::fe10() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe10)
  return _internal_fe10();
}
inline void Fea12::_internal_set_fe10(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe10_ = value;
}
inline void Fea12::set_fe10(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe10(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe10)
}

// uint64 fe11 = 12;
inline void Fea12::clear_fe11() {
  fe11_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::_internal_fe11() const {
  return fe11_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fea12::fe11() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe11)
  return _internal_fe11();
}
inline void Fea12::_internal_set_fe11(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fe11_ = value;
}
inline void Fea12::set_fe11(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fe11(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe11)
}

// -------------------------------------------------------------------

// HashValueGL

// .hashdb.v1.Fea hash = 1;
inline bool HashValueGL::_internal_has_hash() const {
  return this != internal_default_instance() && hash_ != nullptr;
}
inline bool HashValueGL::has_hash() const {
  return _internal_has_hash();
}
inline void HashValueGL::clear_hash() {
  if (GetArena() == nullptr && hash_ != nullptr) {
    delete hash_;
  }
  hash_ = nullptr;
}
inline const ::hashdb::v1::Fea& HashValueGL::_internal_hash() const {
  const ::hashdb::v1::Fea* p = hash_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& HashValueGL::hash() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.HashValueGL.hash)
  return _internal_hash();
}
inline void HashValueGL::unsafe_arena_set_allocated_hash(
    ::hashdb::v1::Fea* hash) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hash_);
  }
  hash_ = hash;
  if (hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.HashValueGL.hash)
}
inline ::hashdb::v1::Fea* HashValueGL::release_hash() {
  auto temp = unsafe_arena_release_hash();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* HashValueGL::unsafe_arena_release_hash() {
  // @@protoc_insertion_point(field_release:hashdb.v1.HashValueGL.hash)
  
  ::hashdb::v1::Fea* temp = hash_;
  hash_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* HashValueGL::_internal_mutable_hash() {
  
  if (hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    hash_ = p;
  }
  return hash_;
}
inline ::hashdb::v1::Fea* HashValueGL::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.HashValueGL.hash)
  return _internal_mutable_hash();
}
inline void HashValueGL::set_allocated_hash(::hashdb::v1::Fea* hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hash_;
  }
  if (hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hash);
    if (message_arena != submessage_arena) {
      hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hash, submessage_arena);
    }
    
  } else {
    
  }
  hash_ = hash;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.HashValueGL.hash)
}

// .hashdb.v1.Fea12 value = 2;
inline bool HashValueGL::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool HashValueGL::has_value() const {
  return _internal_has_value();
}
inline void HashValueGL::clear_value() {
  if (GetArena() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::hashdb::v1::Fea12& HashValueGL::_internal_value() const {
  const ::hashdb::v1::Fea12* p = value_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea12*>(
      &::hashdb::v1::_Fea12_default_instance_);
}
inline const ::hashdb::v1::Fea12& HashValueGL::value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.HashValueGL.value)
  return _internal_value();
}
inline void HashValueGL::unsafe_arena_set_allocated_value(
    ::hashdb::v1::Fea12* value) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.HashValueGL.value)
}
inline ::hashdb::v1::Fea12* HashValueGL::release_value() {
  auto temp = unsafe_arena_release_value();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea12* HashValueGL::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.HashValueGL.value)
  
  ::hashdb::v1::Fea12* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea12* HashValueGL::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea12>(GetArena());
    value_ = p;
  }
  return value_;
}
inline ::hashdb::v1::Fea12* HashValueGL::mutable_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.HashValueGL.value)
  return _internal_mutable_value();
}
inline void HashValueGL::set_allocated_value(::hashdb::v1::Fea12* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.HashValueGL.value)
}

// -------------------------------------------------------------------

// KeyValue

// .hashdb.v1.Fea key = 1;
inline bool KeyValue::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool KeyValue::has_key() const {
  return _internal_has_key();
}
inline void KeyValue::clear_key() {
  if (GetArena() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::hashdb::v1::Fea& KeyValue::_internal_key() const {
  const ::hashdb::v1::Fea* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hashdb::v1::Fea*>(
      &::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.KeyValue.key)
  return _internal_key();
}
inline void KeyValue::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.KeyValue.key)
}
inline ::hashdb::v1::Fea* KeyValue::release_key() {
  auto temp = unsafe_arena_release_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hashdb::v1::Fea* KeyValue::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.KeyValue.key)
  
  ::hashdb::v1::Fea* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* KeyValue::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArena());
    key_ = p;
  }
  return key_;
}
inline ::hashdb::v1::Fea* KeyValue::mutable_key() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.KeyValue.key)
  return _internal_mutable_key();
}
inline void KeyValue::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.KeyValue.key)
}

// string value = 2;
inline void KeyValue::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& KeyValue::value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.KeyValue.value)
  return _internal_value();
}
inline void KeyValue::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.KeyValue.value)
}
inline std::string* KeyValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.KeyValue.value)
  return _internal_mutable_value();
}
inline const std::string& KeyValue::_internal_value() const {
  return value_.Get();
}
inline void KeyValue::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void KeyValue::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hashdb.v1.KeyValue.value)
}
inline void KeyValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hashdb.v1.KeyValue.value)
}
inline void KeyValue::set_value(const char* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hashdb.v1.KeyValue.value)
}
inline std::string* KeyValue::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* KeyValue::release_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.KeyValue.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void KeyValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.KeyValue.value)
}
inline std::string* KeyValue::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hashdb.v1.KeyValue.value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void KeyValue::unsafe_arena_set_allocated_value(
    std::string* value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (value != nullptr) {
    
  } else {
    
  }
  value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.KeyValue.value)
}

// -------------------------------------------------------------------

// FeList

// repeated uint64 fe = 1;
inline int FeList::_internal_fe_size() const {
  return fe_.size();
}
inline int FeList::fe_size() const {
  return _internal_fe_size();
}
inline void FeList::clear_fe() {
  fe_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FeList::_internal_fe(int index) const {
  return fe_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FeList::fe(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FeList.fe)
  return _internal_fe(index);
}
inline void FeList::set_fe(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  fe_.Set(index, value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FeList.fe)
}
inline void FeList::_internal_add_fe(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  fe_.Add(value);
}
inline void FeList::add_fe(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_fe(value);
  // @@protoc_insertion_point(field_add:hashdb.v1.FeList.fe)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
FeList::_internal_fe() const {
  return fe_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
FeList::fe() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.FeList.fe)
  return _internal_fe();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
FeList::_internal_mutable_fe() {
  return &fe_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
FeList::mutable_fe() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.FeList.fe)
  return _internal_mutable_fe();
}

// -------------------------------------------------------------------

// SiblingList

// repeated uint64 sibling = 1;
inline int SiblingList::_internal_sibling_size() const {
  return sibling_.size();
}
inline int SiblingList::sibling_size() const {
  return _internal_sibling_size();
}
inline void SiblingList::clear_sibling() {
  sibling_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SiblingList::_internal_sibling(int index) const {
  return sibling_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SiblingList::sibling(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SiblingList.sibling)
  return _internal_sibling(index);
}
inline void SiblingList::set_sibling(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  sibling_.Set(index, value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SiblingList.sibling)
}
inline void SiblingList::_internal_add_sibling(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  sibling_.Add(value);
}
inline void SiblingList::add_sibling(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_sibling(value);
  // @@protoc_insertion_point(field_add:hashdb.v1.SiblingList.sibling)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
SiblingList::_internal_sibling() const {
  return sibling_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
SiblingList::sibling() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.SiblingList.sibling)
  return _internal_sibling();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
SiblingList::_internal_mutable_sibling() {
  return &sibling_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
SiblingList::mutable_sibling() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.SiblingList.sibling)
  return _internal_mutable_sibling();
}

// -------------------------------------------------------------------

// ResultCode

// .hashdb.v1.ResultCode.Code code = 1;
inline void ResultCode::clear_code() {
  code_ = 0;
}
inline ::hashdb::v1::ResultCode_Code ResultCode::_internal_code() const {
  return static_cast< ::hashdb::v1::ResultCode_Code >(code_);
}
inline ::hashdb::v1::ResultCode_Code ResultCode::code() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ResultCode.code)
  return _internal_code();
}
inline void ResultCode::_internal_set_code(::hashdb::v1::ResultCode_Code value) {
  
  code_ = value;
}
inline void ResultCode::set_code(::hashdb::v1::ResultCode_Code value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.ResultCode.code)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace hashdb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hashdb::v1::ResultCode_Code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hashdb::v1::ResultCode_Code>() {
  return ::hashdb::v1::ResultCode_Code_descriptor();
}
template <> struct is_proto_enum< ::hashdb::v1::Persistence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hashdb::v1::Persistence>() {
  return ::hashdb::v1::Persistence_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_hashdb_2eproto
